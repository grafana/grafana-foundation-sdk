{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Query": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "datasourceUid": {
          "type": "string",
          "description": "Grafana data source unique identifier; it should be '__expr__' for a Server Side Expression operation."
        },
        "model": {
          "type": "object",
          "additionalProperties": {},
          "description": "JSON is the raw JSON query and includes the above properties as well as custom properties."
        },
        "queryType": {
          "type": "string",
          "description": "QueryType is an optional identifier for the type of query.\nIt can be used to distinguish different types of queries."
        },
        "refId": {
          "type": "string",
          "description": "RefID is the unique identifier of the query, set by the frontend call."
        },
        "relativeTimeRange": {
          "$ref": "#/definitions/RelativeTimeRange",
          "description": "RelativeTimeRange is the per query start and end time\nfor requests."
        }
      }
    },
    "RuleGroup": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "folderUid": {
          "type": "string"
        },
        "interval": {
          "$ref": "#/definitions/Duration",
          "description": "The interval, in seconds, at which all rules in the group are evaluated.\nIf a group contains many rules, the rules are evaluated sequentially."
        },
        "rules": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Rule"
          }
        },
        "title": {
          "type": "string"
        }
      }
    },
    "NotificationSettings": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "receiver"
      ],
      "properties": {
        "active_time_intervals": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Override the times when notifications should not be muted. These must match the name of a mute time interval defined\nin the alertmanager configuration time_intervals section. All notifications will be suppressed unless they are sent\nat the time that matches any interval."
        },
        "group_by": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Override the labels by which incoming alerts are grouped together. For example, multiple alerts coming in for\ncluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels\nuse the special value '...' as the sole label name.\nThis effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what\nyou want, unless you have a very low alert volume or your upstream notification system performs its own grouping.\nMust include 'alertname' and 'grafana_folder' if not using '...'.",
          "default": [
            "alertname",
            "grafana_folder"
          ]
        },
        "group_interval": {
          "type": "string",
          "description": "Override how long to wait before sending a notification about new alerts that are added to a group of alerts for\nwhich an initial notification has already been sent. (Usually ~5m or more.)"
        },
        "group_wait": {
          "type": "string",
          "description": "Override how long to initially wait to send a notification for a group of alerts. Allows to wait for an\ninhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)"
        },
        "mute_time_intervals": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Override the times when notifications should be muted. These must match the name of a mute time interval defined\nin the alertmanager configuration time_intervals section. When muted it will not send any notifications, but\notherwise acts normally."
        },
        "receiver": {
          "type": "string",
          "description": "Name of the receiver to send notifications to."
        },
        "repeat_interval": {
          "type": "string",
          "description": "Override how long to wait before sending a notification again if it has already been sent successfully for an\nalert. (Usually ~3h or more).\nNote that this parameter is implicitly bound by Alertmanager's `--data.retention` configuration flag.\nNotifications will be resent after either repeat_interval or the data retention period have passed, whichever\noccurs first. `repeat_interval` should not be less than `group_interval`."
        }
      }
    },
    "Duration": {
      "type": "integer",
      "description": "Duration in seconds."
    },
    "ContactPoint": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "settings",
        "type"
      ],
      "properties": {
        "disableResolveMessage": {
          "type": "boolean"
        },
        "name": {
          "type": "string",
          "description": "Name is used as grouping key in the UI. Contact points with the\nsame name will be grouped in the UI."
        },
        "provenance": {
          "type": "string"
        },
        "settings": {
          "$ref": "#/definitions/Json"
        },
        "type": {
          "enum": [
            "alertmanager",
            "dingding",
            "discord",
            "email",
            "googlechat",
            "kafka",
            "line",
            "opsgenie",
            "pagerduty",
            "pushover",
            "sensugo",
            "slack",
            "teams",
            "telegram",
            "threema",
            "victorops",
            "webhook",
            "wecom"
          ]
        },
        "uid": {
          "type": "string",
          "minLength": 1,
          "maxLength": 40,
          "description": "UID is the unique identifier of the contact point. The UID can be\nset by the user."
        }
      },
      "description": "EmbeddedContactPoint is the contact point type that is used\nby grafanas embedded alertmanager implementation."
    },
    "Json": {
      "type": "object",
      "additionalProperties": {}
    },
    "MatchRegexps": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "MatchType": {
      "enum": [
        "=",
        "!=",
        "=~",
        "!~"
      ]
    },
    "Matcher": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "Name": {
          "type": "string"
        },
        "Type": {
          "$ref": "#/definitions/MatchType"
        },
        "Value": {
          "type": "string"
        }
      }
    },
    "Matchers": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/Matcher"
      },
      "description": "Matchers is a slice of Matchers that is sortable, implements Stringer, and\nprovides a Matches method to match a LabelSet against all Matchers in the\nslice. Note that some users of Matchers might require it to be sorted."
    },
    "MuteTiming": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string"
        },
        "time_intervals": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TimeInterval"
          }
        }
      }
    },
    "NotificationTemplate": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string"
        },
        "provenance": {
          "$ref": "#/definitions/Provenance"
        },
        "template": {
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "Provenance": {
      "type": "string"
    },
    "Rule": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "condition",
        "data",
        "execErrState",
        "folderUID",
        "for",
        "noDataState",
        "orgID",
        "ruleGroup",
        "title"
      ],
      "properties": {
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "condition": {
          "type": "string"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Query"
          }
        },
        "execErrState": {
          "enum": [
            "OK",
            "Alerting",
            "Error"
          ]
        },
        "folderUID": {
          "type": "string"
        },
        "for": {
          "type": "string",
          "description": "The amount of time, in seconds, for which the rule must be breached for the rule to be considered to be Firing.\nBefore this time has elapsed, the rule is only considered to be Pending."
        },
        "id": {
          "type": "integer"
        },
        "isPaused": {
          "type": "boolean"
        },
        "keep_firing_for": {
          "type": "string"
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "missingSeriesEvalsToResolve": {
          "type": "integer"
        },
        "noDataState": {
          "enum": [
            "Alerting",
            "NoData",
            "OK"
          ]
        },
        "notification_settings": {
          "$ref": "#/definitions/NotificationSettings"
        },
        "orgID": {
          "type": "integer"
        },
        "provenance": {
          "$ref": "#/definitions/Provenance"
        },
        "record": {
          "$ref": "#/definitions/RecordRule"
        },
        "ruleGroup": {
          "type": "string",
          "minLength": 1,
          "maxLength": 190
        },
        "title": {
          "type": "string",
          "minLength": 1,
          "maxLength": 190
        },
        "uid": {
          "type": "string",
          "minLength": 1,
          "maxLength": 40
        },
        "updated": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "RecordRule": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "from",
        "metric"
      ],
      "properties": {
        "from": {
          "type": "string",
          "description": "Which expression node should be used as the input for the recorded metric."
        },
        "metric": {
          "type": "string",
          "description": "Name of the recorded metric."
        },
        "target_datasource_uid": {
          "type": "string",
          "description": "Which data source should be used to write the output of the recording rule, specified by UID."
        }
      }
    },
    "RelativeTimeRange": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "from": {
          "$ref": "#/definitions/Duration",
          "description": "A Duration represents the elapsed time between two instants\nas an int64 nanosecond count. The representation limits the\nlargest representable duration to approximately 290 years."
        },
        "to": {
          "$ref": "#/definitions/Duration",
          "description": "A Duration represents the elapsed time between two instants\nas an int64 nanosecond count. The representation limits the\nlargest representable duration to approximately 290 years."
        }
      },
      "description": "RelativeTimeRange is the per query start and end time\nfor requests."
    },
    "NotificationPolicy": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "active_time_intervals": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "continue": {
          "type": "boolean"
        },
        "group_by": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "group_interval": {
          "type": "string"
        },
        "group_wait": {
          "type": "string"
        },
        "match": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Deprecated. Remove before v1.0 release."
        },
        "match_re": {
          "$ref": "#/definitions/MatchRegexps"
        },
        "matchers": {
          "$ref": "#/definitions/Matchers",
          "description": "Matchers is a slice of Matchers that is sortable, implements Stringer, and\nprovides a Matches method to match a LabelSet against all Matchers in the\nslice. Note that some users of Matchers might require it to be sorted."
        },
        "mute_time_intervals": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "receiver": {
          "type": "string"
        },
        "repeat_interval": {
          "type": "string"
        },
        "routes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NotificationPolicy"
          }
        }
      }
    },
    "TimeInterval": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "times": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TimeRange"
          }
        },
        "weekdays": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/WeekdayRange"
          }
        },
        "days_of_month": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DayOfMonthRange"
          }
        },
        "months": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MonthRange"
          }
        },
        "years": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/YearRange"
          }
        },
        "location": {
          "$ref": "#/definitions/Location"
        }
      }
    },
    "TimeRange": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "from": {
          "type": "string",
          "format": "date-time"
        },
        "to": {
          "type": "string",
          "format": "date-time"
        }
      },
      "description": "Redefining this to avoid an import cycle"
    },
    "WeekdayRange": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "begin": {
          "type": "integer"
        },
        "end": {
          "type": "integer"
        }
      }
    },
    "DayOfMonthRange": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "begin": {
          "type": "integer"
        },
        "end": {
          "type": "integer"
        }
      }
    },
    "YearRange": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "begin": {
          "type": "integer"
        },
        "end": {
          "type": "integer"
        }
      }
    },
    "MonthRange": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "begin": {
          "type": "integer"
        },
        "end": {
          "type": "integer"
        }
      }
    },
    "Location": {
      "type": "string"
    }
  }
}