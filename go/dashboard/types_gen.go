// Code generated - EDITING IS FUTILE. DO NOT EDIT.

package dashboard

import (
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"time"

	cog "github.com/grafana/grafana-foundation-sdk/go/cog"
	variants "github.com/grafana/grafana-foundation-sdk/go/cog/variants"
)

type Dashboard struct {
	// Unique numeric identifier for the dashboard.
	// `id` is internal to a specific Grafana instance. `uid` should be used to identify a dashboard across Grafana instances.
	Id *int64 `json:"id,omitempty"`
	// Unique dashboard identifier that can be generated by anyone. string (8-40)
	Uid *string `json:"uid,omitempty"`
	// Title of dashboard.
	Title *string `json:"title,omitempty"`
	// Description of dashboard.
	Description *string `json:"description,omitempty"`
	// This property should only be used in dashboards defined by plugins.  It is a quick check
	// to see if the version has changed since the last time.
	Revision *int64 `json:"revision,omitempty"`
	// ID of a dashboard imported from the https://grafana.com/grafana/dashboards/ portal
	GnetId *string `json:"gnetId,omitempty"`
	// Tags associated with dashboard.
	Tags []string `json:"tags,omitempty"`
	// Theme of dashboard.
	// Default value: dark.
	Style DashboardStyle `json:"style"`
	// Timezone of dashboard. Accepted values are IANA TZDB zone ID or "browser" or "utc".
	Timezone *string `json:"timezone,omitempty"`
	// Whether a dashboard is editable or not.
	Editable bool `json:"editable"`
	// Configuration of dashboard cursor sync behavior.
	// Accepted values are 0 (sync turned off), 1 (shared crosshair), 2 (shared crosshair and tooltip).
	GraphTooltip DashboardCursorSync `json:"graphTooltip"`
	// Time range for dashboard.
	// Accepted values are relative time strings like {from: 'now-6h', to: 'now'} or absolute time strings like {from: '2020-07-10T08:00:00.000Z', to: '2020-07-10T14:00:00.000Z'}.
	Time *DashboardDashboardTime `json:"time,omitempty"`
	// Configuration of the time picker shown at the top of a dashboard.
	Timepicker *TimePicker `json:"timepicker,omitempty"`
	// The month that the fiscal year starts on.  0 = January, 11 = December
	FiscalYearStartMonth *uint8 `json:"fiscalYearStartMonth,omitempty"`
	// When set to true, the dashboard will redraw panels at an interval matching the pixel width.
	// This will keep data "moving left" regardless of the query refresh rate. This setting helps
	// avoid dashboards presenting stale live data
	LiveNow *bool `json:"liveNow,omitempty"`
	// Day when the week starts. Expressed by the name of the day in lowercase, e.g. "monday".
	WeekStart *string `json:"weekStart,omitempty"`
	// Refresh rate of dashboard. Represented via interval string, e.g. "5s", "1m", "1h", "1d".
	Refresh *StringOrBool `json:"refresh,omitempty"`
	// Version of the JSON schema, incremented each time a Grafana update brings
	// changes to said schema.
	SchemaVersion uint16 `json:"schemaVersion"`
	// Version of the dashboard, incremented each time the dashboard is updated.
	Version *uint32 `json:"version,omitempty"`
	// List of dashboard panels
	Panels []PanelOrRowPanel `json:"panels,omitempty"`
	// Configured template variables
	Templating DashboardDashboardTemplating `json:"templating"`
	// Contains the list of annotations that are associated with the dashboard.
	// Annotations are used to overlay event markers and overlay event tags on graphs.
	// Grafana comes with a native annotation store and the ability to add annotation events directly from the graph panel or via the HTTP API.
	// See https://grafana.com/docs/grafana/latest/dashboards/build-dashboards/annotate-visualizations/
	Annotations AnnotationContainer `json:"annotations"`
	// Links with references to other dashboards or external websites.
	Links []DashboardLink `json:"links,omitempty"`
	// Snapshot options. They are present only if the dashboard is a snapshot.
	Snapshot *Snapshot `json:"snapshot,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `Dashboard` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *Dashboard) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "id"
	if fields["id"] != nil {
		if string(fields["id"]) != "null" {
			if err := json.Unmarshal(fields["id"], &resource.Id); err != nil {
				errs = append(errs, cog.MakeBuildErrors("id", err)...)
			}

		}
		delete(fields, "id")

	}
	// Field "uid"
	if fields["uid"] != nil {
		if string(fields["uid"]) != "null" {
			if err := json.Unmarshal(fields["uid"], &resource.Uid); err != nil {
				errs = append(errs, cog.MakeBuildErrors("uid", err)...)
			}

		}
		delete(fields, "uid")

	}
	// Field "title"
	if fields["title"] != nil {
		if string(fields["title"]) != "null" {
			if err := json.Unmarshal(fields["title"], &resource.Title); err != nil {
				errs = append(errs, cog.MakeBuildErrors("title", err)...)
			}

		}
		delete(fields, "title")

	}
	// Field "description"
	if fields["description"] != nil {
		if string(fields["description"]) != "null" {
			if err := json.Unmarshal(fields["description"], &resource.Description); err != nil {
				errs = append(errs, cog.MakeBuildErrors("description", err)...)
			}

		}
		delete(fields, "description")

	}
	// Field "revision"
	if fields["revision"] != nil {
		if string(fields["revision"]) != "null" {
			if err := json.Unmarshal(fields["revision"], &resource.Revision); err != nil {
				errs = append(errs, cog.MakeBuildErrors("revision", err)...)
			}

		}
		delete(fields, "revision")

	}
	// Field "gnetId"
	if fields["gnetId"] != nil {
		if string(fields["gnetId"]) != "null" {
			if err := json.Unmarshal(fields["gnetId"], &resource.GnetId); err != nil {
				errs = append(errs, cog.MakeBuildErrors("gnetId", err)...)
			}

		}
		delete(fields, "gnetId")

	}
	// Field "tags"
	if fields["tags"] != nil {
		if string(fields["tags"]) != "null" {

			if err := json.Unmarshal(fields["tags"], &resource.Tags); err != nil {
				errs = append(errs, cog.MakeBuildErrors("tags", err)...)
			}

		}
		delete(fields, "tags")

	}
	// Field "style"
	if fields["style"] != nil {
		if string(fields["style"]) != "null" {
			if err := json.Unmarshal(fields["style"], &resource.Style); err != nil {
				errs = append(errs, cog.MakeBuildErrors("style", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("style", errors.New("required field is null"))...)

		}
		delete(fields, "style")
	} else {
		errs = append(errs, cog.MakeBuildErrors("style", errors.New("required field is missing from input"))...)
	}
	// Field "timezone"
	if fields["timezone"] != nil {
		if string(fields["timezone"]) != "null" {
			if err := json.Unmarshal(fields["timezone"], &resource.Timezone); err != nil {
				errs = append(errs, cog.MakeBuildErrors("timezone", err)...)
			}

		}
		delete(fields, "timezone")

	}
	// Field "editable"
	if fields["editable"] != nil {
		if string(fields["editable"]) != "null" {
			if err := json.Unmarshal(fields["editable"], &resource.Editable); err != nil {
				errs = append(errs, cog.MakeBuildErrors("editable", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("editable", errors.New("required field is null"))...)

		}
		delete(fields, "editable")
	} else {
		errs = append(errs, cog.MakeBuildErrors("editable", errors.New("required field is missing from input"))...)
	}
	// Field "graphTooltip"
	if fields["graphTooltip"] != nil {
		if string(fields["graphTooltip"]) != "null" {
			if err := json.Unmarshal(fields["graphTooltip"], &resource.GraphTooltip); err != nil {
				errs = append(errs, cog.MakeBuildErrors("graphTooltip", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("graphTooltip", errors.New("required field is null"))...)

		}
		delete(fields, "graphTooltip")
	} else {
		errs = append(errs, cog.MakeBuildErrors("graphTooltip", errors.New("required field is missing from input"))...)
	}
	// Field "time"
	if fields["time"] != nil {
		if string(fields["time"]) != "null" {

			resource.Time = &DashboardDashboardTime{}
			if err := resource.Time.UnmarshalJSONStrict(fields["time"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("time", err)...)
			}

		}
		delete(fields, "time")

	}
	// Field "timepicker"
	if fields["timepicker"] != nil {
		if string(fields["timepicker"]) != "null" {

			resource.Timepicker = &TimePicker{}
			if err := resource.Timepicker.UnmarshalJSONStrict(fields["timepicker"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("timepicker", err)...)
			}

		}
		delete(fields, "timepicker")

	}
	// Field "fiscalYearStartMonth"
	if fields["fiscalYearStartMonth"] != nil {
		if string(fields["fiscalYearStartMonth"]) != "null" {
			if err := json.Unmarshal(fields["fiscalYearStartMonth"], &resource.FiscalYearStartMonth); err != nil {
				errs = append(errs, cog.MakeBuildErrors("fiscalYearStartMonth", err)...)
			}

		}
		delete(fields, "fiscalYearStartMonth")

	}
	// Field "liveNow"
	if fields["liveNow"] != nil {
		if string(fields["liveNow"]) != "null" {
			if err := json.Unmarshal(fields["liveNow"], &resource.LiveNow); err != nil {
				errs = append(errs, cog.MakeBuildErrors("liveNow", err)...)
			}

		}
		delete(fields, "liveNow")

	}
	// Field "weekStart"
	if fields["weekStart"] != nil {
		if string(fields["weekStart"]) != "null" {
			if err := json.Unmarshal(fields["weekStart"], &resource.WeekStart); err != nil {
				errs = append(errs, cog.MakeBuildErrors("weekStart", err)...)
			}

		}
		delete(fields, "weekStart")

	}
	// Field "refresh"
	if fields["refresh"] != nil {
		if string(fields["refresh"]) != "null" {

			resource.Refresh = &StringOrBool{}
			if err := resource.Refresh.UnmarshalJSONStrict(fields["refresh"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("refresh", err)...)
			}

		}
		delete(fields, "refresh")

	}
	// Field "schemaVersion"
	if fields["schemaVersion"] != nil {
		if string(fields["schemaVersion"]) != "null" {
			if err := json.Unmarshal(fields["schemaVersion"], &resource.SchemaVersion); err != nil {
				errs = append(errs, cog.MakeBuildErrors("schemaVersion", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("schemaVersion", errors.New("required field is null"))...)

		}
		delete(fields, "schemaVersion")
	} else {
		errs = append(errs, cog.MakeBuildErrors("schemaVersion", errors.New("required field is missing from input"))...)
	}
	// Field "version"
	if fields["version"] != nil {
		if string(fields["version"]) != "null" {
			if err := json.Unmarshal(fields["version"], &resource.Version); err != nil {
				errs = append(errs, cog.MakeBuildErrors("version", err)...)
			}

		}
		delete(fields, "version")

	}
	// Field "panels"
	if fields["panels"] != nil {
		if string(fields["panels"]) != "null" {

			partialArray := []json.RawMessage{}
			if err := json.Unmarshal(fields["panels"], &partialArray); err != nil {
				return err
			}

			for i1 := range partialArray {
				var result1 PanelOrRowPanel

				result1 = PanelOrRowPanel{}
				if err := result1.UnmarshalJSONStrict(partialArray[i1]); err != nil {
					errs = append(errs, cog.MakeBuildErrors("panels["+strconv.Itoa(i1)+"]", err)...)
				}
				resource.Panels = append(resource.Panels, result1)
			}

		}
		delete(fields, "panels")

	}
	// Field "templating"
	if fields["templating"] != nil {
		if string(fields["templating"]) != "null" {

			resource.Templating = DashboardDashboardTemplating{}
			if err := resource.Templating.UnmarshalJSONStrict(fields["templating"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("templating", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("templating", errors.New("required field is null"))...)

		}
		delete(fields, "templating")
	} else {
		errs = append(errs, cog.MakeBuildErrors("templating", errors.New("required field is missing from input"))...)
	}
	// Field "annotations"
	if fields["annotations"] != nil {
		if string(fields["annotations"]) != "null" {

			resource.Annotations = AnnotationContainer{}
			if err := resource.Annotations.UnmarshalJSONStrict(fields["annotations"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("annotations", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("annotations", errors.New("required field is null"))...)

		}
		delete(fields, "annotations")
	} else {
		errs = append(errs, cog.MakeBuildErrors("annotations", errors.New("required field is missing from input"))...)
	}
	// Field "links"
	if fields["links"] != nil {
		if string(fields["links"]) != "null" {

			partialArray := []json.RawMessage{}
			if err := json.Unmarshal(fields["links"], &partialArray); err != nil {
				return err
			}

			for i1 := range partialArray {
				var result1 DashboardLink

				result1 = DashboardLink{}
				if err := result1.UnmarshalJSONStrict(partialArray[i1]); err != nil {
					errs = append(errs, cog.MakeBuildErrors("links["+strconv.Itoa(i1)+"]", err)...)
				}
				resource.Links = append(resource.Links, result1)
			}

		}
		delete(fields, "links")

	}
	// Field "snapshot"
	if fields["snapshot"] != nil {
		if string(fields["snapshot"]) != "null" {

			resource.Snapshot = &Snapshot{}
			if err := resource.Snapshot.UnmarshalJSONStrict(fields["snapshot"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("snapshot", err)...)
			}

		}
		delete(fields, "snapshot")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("Dashboard", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `Dashboard` objects.
func (resource Dashboard) Equals(other Dashboard) bool {
	if resource.Id == nil && other.Id != nil || resource.Id != nil && other.Id == nil {
		return false
	}

	if resource.Id != nil {
		if *resource.Id != *other.Id {
			return false
		}
	}
	if resource.Uid == nil && other.Uid != nil || resource.Uid != nil && other.Uid == nil {
		return false
	}

	if resource.Uid != nil {
		if *resource.Uid != *other.Uid {
			return false
		}
	}
	if resource.Title == nil && other.Title != nil || resource.Title != nil && other.Title == nil {
		return false
	}

	if resource.Title != nil {
		if *resource.Title != *other.Title {
			return false
		}
	}
	if resource.Description == nil && other.Description != nil || resource.Description != nil && other.Description == nil {
		return false
	}

	if resource.Description != nil {
		if *resource.Description != *other.Description {
			return false
		}
	}
	if resource.Revision == nil && other.Revision != nil || resource.Revision != nil && other.Revision == nil {
		return false
	}

	if resource.Revision != nil {
		if *resource.Revision != *other.Revision {
			return false
		}
	}
	if resource.GnetId == nil && other.GnetId != nil || resource.GnetId != nil && other.GnetId == nil {
		return false
	}

	if resource.GnetId != nil {
		if *resource.GnetId != *other.GnetId {
			return false
		}
	}

	if len(resource.Tags) != len(other.Tags) {
		return false
	}

	for i1 := range resource.Tags {
		if resource.Tags[i1] != other.Tags[i1] {
			return false
		}
	}
	if resource.Style != other.Style {
		return false
	}
	if resource.Timezone == nil && other.Timezone != nil || resource.Timezone != nil && other.Timezone == nil {
		return false
	}

	if resource.Timezone != nil {
		if *resource.Timezone != *other.Timezone {
			return false
		}
	}
	if resource.Editable != other.Editable {
		return false
	}
	if resource.GraphTooltip != other.GraphTooltip {
		return false
	}
	if resource.Time == nil && other.Time != nil || resource.Time != nil && other.Time == nil {
		return false
	}

	if resource.Time != nil {
		if !resource.Time.Equals(*other.Time) {
			return false
		}
	}
	if resource.Timepicker == nil && other.Timepicker != nil || resource.Timepicker != nil && other.Timepicker == nil {
		return false
	}

	if resource.Timepicker != nil {
		if !resource.Timepicker.Equals(*other.Timepicker) {
			return false
		}
	}
	if resource.FiscalYearStartMonth == nil && other.FiscalYearStartMonth != nil || resource.FiscalYearStartMonth != nil && other.FiscalYearStartMonth == nil {
		return false
	}

	if resource.FiscalYearStartMonth != nil {
		if *resource.FiscalYearStartMonth != *other.FiscalYearStartMonth {
			return false
		}
	}
	if resource.LiveNow == nil && other.LiveNow != nil || resource.LiveNow != nil && other.LiveNow == nil {
		return false
	}

	if resource.LiveNow != nil {
		if *resource.LiveNow != *other.LiveNow {
			return false
		}
	}
	if resource.WeekStart == nil && other.WeekStart != nil || resource.WeekStart != nil && other.WeekStart == nil {
		return false
	}

	if resource.WeekStart != nil {
		if *resource.WeekStart != *other.WeekStart {
			return false
		}
	}
	if resource.Refresh == nil && other.Refresh != nil || resource.Refresh != nil && other.Refresh == nil {
		return false
	}

	if resource.Refresh != nil {
		if !resource.Refresh.Equals(*other.Refresh) {
			return false
		}
	}
	if resource.SchemaVersion != other.SchemaVersion {
		return false
	}
	if resource.Version == nil && other.Version != nil || resource.Version != nil && other.Version == nil {
		return false
	}

	if resource.Version != nil {
		if *resource.Version != *other.Version {
			return false
		}
	}

	if len(resource.Panels) != len(other.Panels) {
		return false
	}

	for i1 := range resource.Panels {
		if !resource.Panels[i1].Equals(other.Panels[i1]) {
			return false
		}
	}
	if !resource.Templating.Equals(other.Templating) {
		return false
	}
	if !resource.Annotations.Equals(other.Annotations) {
		return false
	}

	if len(resource.Links) != len(other.Links) {
		return false
	}

	for i1 := range resource.Links {
		if !resource.Links[i1].Equals(other.Links[i1]) {
			return false
		}
	}
	if resource.Snapshot == nil && other.Snapshot != nil || resource.Snapshot != nil && other.Snapshot == nil {
		return false
	}

	if resource.Snapshot != nil {
		if !resource.Snapshot.Equals(*other.Snapshot) {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `Dashboard` fields for violations and returns them.
func (resource Dashboard) Validate() error {
	var errs cog.BuildErrors
	if resource.Time != nil {
		if err := resource.Time.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("time", err)...)
		}
	}
	if resource.Timepicker != nil {
		if err := resource.Timepicker.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("timepicker", err)...)
		}
	}
	if resource.FiscalYearStartMonth != nil {
		if !(*resource.FiscalYearStartMonth < 12) {
			errs = append(errs, cog.MakeBuildErrors(
				"fiscalYearStartMonth",
				errors.New("must be < 12"),
			)...)
		}
	}
	if resource.Refresh != nil {
		if err := resource.Refresh.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("refresh", err)...)
		}
	}

	for i1 := range resource.Panels {
		if err := resource.Panels[i1].Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("panels["+strconv.Itoa(i1)+"]", err)...)
		}
	}
	if err := resource.Templating.Validate(); err != nil {
		errs = append(errs, cog.MakeBuildErrors("templating", err)...)
	}
	if err := resource.Annotations.Validate(); err != nil {
		errs = append(errs, cog.MakeBuildErrors("annotations", err)...)
	}

	for i1 := range resource.Links {
		if err := resource.Links[i1].Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("links["+strconv.Itoa(i1)+"]", err)...)
		}
	}
	if resource.Snapshot != nil {
		if err := resource.Snapshot.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("snapshot", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// TODO: this should be a regular DataQuery that depends on the selected dashboard
// these match the properties of the "grafana" datasouce that is default in most dashboards
type AnnotationTarget struct {
	// Only required/valid for the grafana datasource...
	// but code+tests is already depending on it so hard to change
	Limit int64 `json:"limit"`
	// Only required/valid for the grafana datasource...
	// but code+tests is already depending on it so hard to change
	MatchAny bool `json:"matchAny"`
	// Only required/valid for the grafana datasource...
	// but code+tests is already depending on it so hard to change
	Tags []string `json:"tags"`
	// Only required/valid for the grafana datasource...
	// but code+tests is already depending on it so hard to change
	Type string `json:"type"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `AnnotationTarget` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *AnnotationTarget) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "limit"
	if fields["limit"] != nil {
		if string(fields["limit"]) != "null" {
			if err := json.Unmarshal(fields["limit"], &resource.Limit); err != nil {
				errs = append(errs, cog.MakeBuildErrors("limit", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("limit", errors.New("required field is null"))...)

		}
		delete(fields, "limit")
	} else {
		errs = append(errs, cog.MakeBuildErrors("limit", errors.New("required field is missing from input"))...)
	}
	// Field "matchAny"
	if fields["matchAny"] != nil {
		if string(fields["matchAny"]) != "null" {
			if err := json.Unmarshal(fields["matchAny"], &resource.MatchAny); err != nil {
				errs = append(errs, cog.MakeBuildErrors("matchAny", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("matchAny", errors.New("required field is null"))...)

		}
		delete(fields, "matchAny")
	} else {
		errs = append(errs, cog.MakeBuildErrors("matchAny", errors.New("required field is missing from input"))...)
	}
	// Field "tags"
	if fields["tags"] != nil {
		if string(fields["tags"]) != "null" {

			if err := json.Unmarshal(fields["tags"], &resource.Tags); err != nil {
				errs = append(errs, cog.MakeBuildErrors("tags", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("tags", errors.New("required field is null"))...)

		}
		delete(fields, "tags")
	} else {
		errs = append(errs, cog.MakeBuildErrors("tags", errors.New("required field is missing from input"))...)
	}
	// Field "type"
	if fields["type"] != nil {
		if string(fields["type"]) != "null" {
			if err := json.Unmarshal(fields["type"], &resource.Type); err != nil {
				errs = append(errs, cog.MakeBuildErrors("type", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is null"))...)

		}
		delete(fields, "type")
	} else {
		errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("AnnotationTarget", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `AnnotationTarget` objects.
func (resource AnnotationTarget) Equals(other AnnotationTarget) bool {
	if resource.Limit != other.Limit {
		return false
	}
	if resource.MatchAny != other.MatchAny {
		return false
	}

	if len(resource.Tags) != len(other.Tags) {
		return false
	}

	for i1 := range resource.Tags {
		if resource.Tags[i1] != other.Tags[i1] {
			return false
		}
	}
	if resource.Type != other.Type {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `AnnotationTarget` fields for violations and returns them.
func (resource AnnotationTarget) Validate() error {
	return nil
}

type AnnotationPanelFilter struct {
	// Should the specified panels be included or excluded
	Exclude *bool `json:"exclude,omitempty"`
	// Panel IDs that should be included or excluded
	Ids []uint8 `json:"ids"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `AnnotationPanelFilter` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *AnnotationPanelFilter) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "exclude"
	if fields["exclude"] != nil {
		if string(fields["exclude"]) != "null" {
			if err := json.Unmarshal(fields["exclude"], &resource.Exclude); err != nil {
				errs = append(errs, cog.MakeBuildErrors("exclude", err)...)
			}

		}
		delete(fields, "exclude")

	}
	// Field "ids"
	if fields["ids"] != nil {
		if string(fields["ids"]) != "null" {

			if err := json.Unmarshal(fields["ids"], &resource.Ids); err != nil {
				errs = append(errs, cog.MakeBuildErrors("ids", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("ids", errors.New("required field is null"))...)

		}
		delete(fields, "ids")
	} else {
		errs = append(errs, cog.MakeBuildErrors("ids", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("AnnotationPanelFilter", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `AnnotationPanelFilter` objects.
func (resource AnnotationPanelFilter) Equals(other AnnotationPanelFilter) bool {
	if resource.Exclude == nil && other.Exclude != nil || resource.Exclude != nil && other.Exclude == nil {
		return false
	}

	if resource.Exclude != nil {
		if *resource.Exclude != *other.Exclude {
			return false
		}
	}

	if len(resource.Ids) != len(other.Ids) {
		return false
	}

	for i1 := range resource.Ids {
		if resource.Ids[i1] != other.Ids[i1] {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `AnnotationPanelFilter` fields for violations and returns them.
func (resource AnnotationPanelFilter) Validate() error {
	return nil
}

// Contains the list of annotations that are associated with the dashboard.
// Annotations are used to overlay event markers and overlay event tags on graphs.
// Grafana comes with a native annotation store and the ability to add annotation events directly from the graph panel or via the HTTP API.
// See https://grafana.com/docs/grafana/latest/dashboards/build-dashboards/annotate-visualizations/
type AnnotationContainer struct {
	// List of annotations
	List []AnnotationQuery `json:"list,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `AnnotationContainer` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *AnnotationContainer) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "list"
	if fields["list"] != nil {
		if string(fields["list"]) != "null" {

			partialArray := []json.RawMessage{}
			if err := json.Unmarshal(fields["list"], &partialArray); err != nil {
				return err
			}

			for i1 := range partialArray {
				var result1 AnnotationQuery

				result1 = AnnotationQuery{}
				if err := result1.UnmarshalJSONStrict(partialArray[i1]); err != nil {
					errs = append(errs, cog.MakeBuildErrors("list["+strconv.Itoa(i1)+"]", err)...)
				}
				resource.List = append(resource.List, result1)
			}

		}
		delete(fields, "list")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("AnnotationContainer", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `AnnotationContainer` objects.
func (resource AnnotationContainer) Equals(other AnnotationContainer) bool {

	if len(resource.List) != len(other.List) {
		return false
	}

	for i1 := range resource.List {
		if !resource.List[i1].Equals(other.List[i1]) {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `AnnotationContainer` fields for violations and returns them.
func (resource AnnotationContainer) Validate() error {
	var errs cog.BuildErrors

	for i1 := range resource.List {
		if err := resource.List[i1].Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("list["+strconv.Itoa(i1)+"]", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// TODO docs
// FROM: AnnotationQuery in grafana-data/src/types/annotations.ts
type AnnotationQuery struct {
	// Name of annotation.
	Name string `json:"name"`
	// Datasource where the annotations data is
	Datasource DataSourceRef `json:"datasource"`
	// When enabled the annotation query is issued with every dashboard refresh
	Enable bool `json:"enable"`
	// Annotation queries can be toggled on or off at the top of the dashboard.
	// When hide is true, the toggle is not shown in the dashboard.
	Hide *bool `json:"hide,omitempty"`
	// Color to use for the annotation event markers
	IconColor string `json:"iconColor"`
	// Filters to apply when fetching annotations
	Filter *AnnotationPanelFilter `json:"filter,omitempty"`
	// TODO.. this should just be a normal query target
	Target *AnnotationTarget `json:"target,omitempty"`
	// TODO -- this should not exist here, it is based on the --grafana-- datasource
	Type *string `json:"type,omitempty"`
	Expr *string `json:"expr,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `AnnotationQuery` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *AnnotationQuery) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "name"
	if fields["name"] != nil {
		if string(fields["name"]) != "null" {
			if err := json.Unmarshal(fields["name"], &resource.Name); err != nil {
				errs = append(errs, cog.MakeBuildErrors("name", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("name", errors.New("required field is null"))...)

		}
		delete(fields, "name")
	} else {
		errs = append(errs, cog.MakeBuildErrors("name", errors.New("required field is missing from input"))...)
	}
	// Field "datasource"
	if fields["datasource"] != nil {
		if string(fields["datasource"]) != "null" {

			resource.Datasource = DataSourceRef{}
			if err := resource.Datasource.UnmarshalJSONStrict(fields["datasource"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("datasource", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("datasource", errors.New("required field is null"))...)

		}
		delete(fields, "datasource")
	} else {
		errs = append(errs, cog.MakeBuildErrors("datasource", errors.New("required field is missing from input"))...)
	}
	// Field "enable"
	if fields["enable"] != nil {
		if string(fields["enable"]) != "null" {
			if err := json.Unmarshal(fields["enable"], &resource.Enable); err != nil {
				errs = append(errs, cog.MakeBuildErrors("enable", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("enable", errors.New("required field is null"))...)

		}
		delete(fields, "enable")
	} else {
		errs = append(errs, cog.MakeBuildErrors("enable", errors.New("required field is missing from input"))...)
	}
	// Field "hide"
	if fields["hide"] != nil {
		if string(fields["hide"]) != "null" {
			if err := json.Unmarshal(fields["hide"], &resource.Hide); err != nil {
				errs = append(errs, cog.MakeBuildErrors("hide", err)...)
			}

		}
		delete(fields, "hide")

	}
	// Field "iconColor"
	if fields["iconColor"] != nil {
		if string(fields["iconColor"]) != "null" {
			if err := json.Unmarshal(fields["iconColor"], &resource.IconColor); err != nil {
				errs = append(errs, cog.MakeBuildErrors("iconColor", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("iconColor", errors.New("required field is null"))...)

		}
		delete(fields, "iconColor")
	} else {
		errs = append(errs, cog.MakeBuildErrors("iconColor", errors.New("required field is missing from input"))...)
	}
	// Field "filter"
	if fields["filter"] != nil {
		if string(fields["filter"]) != "null" {

			resource.Filter = &AnnotationPanelFilter{}
			if err := resource.Filter.UnmarshalJSONStrict(fields["filter"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("filter", err)...)
			}

		}
		delete(fields, "filter")

	}
	// Field "target"
	if fields["target"] != nil {
		if string(fields["target"]) != "null" {

			resource.Target = &AnnotationTarget{}
			if err := resource.Target.UnmarshalJSONStrict(fields["target"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("target", err)...)
			}

		}
		delete(fields, "target")

	}
	// Field "type"
	if fields["type"] != nil {
		if string(fields["type"]) != "null" {
			if err := json.Unmarshal(fields["type"], &resource.Type); err != nil {
				errs = append(errs, cog.MakeBuildErrors("type", err)...)
			}

		}
		delete(fields, "type")

	}
	// Field "expr"
	if fields["expr"] != nil {
		if string(fields["expr"]) != "null" {
			if err := json.Unmarshal(fields["expr"], &resource.Expr); err != nil {
				errs = append(errs, cog.MakeBuildErrors("expr", err)...)
			}

		}
		delete(fields, "expr")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("AnnotationQuery", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `AnnotationQuery` objects.
func (resource AnnotationQuery) Equals(other AnnotationQuery) bool {
	if resource.Name != other.Name {
		return false
	}
	if !resource.Datasource.Equals(other.Datasource) {
		return false
	}
	if resource.Enable != other.Enable {
		return false
	}
	if resource.Hide == nil && other.Hide != nil || resource.Hide != nil && other.Hide == nil {
		return false
	}

	if resource.Hide != nil {
		if *resource.Hide != *other.Hide {
			return false
		}
	}
	if resource.IconColor != other.IconColor {
		return false
	}
	if resource.Filter == nil && other.Filter != nil || resource.Filter != nil && other.Filter == nil {
		return false
	}

	if resource.Filter != nil {
		if !resource.Filter.Equals(*other.Filter) {
			return false
		}
	}
	if resource.Target == nil && other.Target != nil || resource.Target != nil && other.Target == nil {
		return false
	}

	if resource.Target != nil {
		if !resource.Target.Equals(*other.Target) {
			return false
		}
	}
	if resource.Type == nil && other.Type != nil || resource.Type != nil && other.Type == nil {
		return false
	}

	if resource.Type != nil {
		if *resource.Type != *other.Type {
			return false
		}
	}
	if resource.Expr == nil && other.Expr != nil || resource.Expr != nil && other.Expr == nil {
		return false
	}

	if resource.Expr != nil {
		if *resource.Expr != *other.Expr {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `AnnotationQuery` fields for violations and returns them.
func (resource AnnotationQuery) Validate() error {
	var errs cog.BuildErrors
	if err := resource.Datasource.Validate(); err != nil {
		errs = append(errs, cog.MakeBuildErrors("datasource", err)...)
	}
	if resource.Filter != nil {
		if err := resource.Filter.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("filter", err)...)
		}
	}
	if resource.Target != nil {
		if err := resource.Target.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("target", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
type VariableModel struct {
	// Unique numeric identifier for the variable.
	Id string `json:"id"`
	// Type of variable
	Type VariableType `json:"type"`
	// Name of variable
	Name string `json:"name"`
	// Optional display name
	Label *string `json:"label,omitempty"`
	// Visibility configuration for the variable
	Hide VariableHide `json:"hide"`
	// Whether the variable value should be managed by URL query params or not
	SkipUrlSync bool `json:"skipUrlSync"`
	// Description of variable. It can be defined but `null`.
	Description *string `json:"description,omitempty"`
	// Query used to fetch values for a variable
	Query *StringOrMap `json:"query,omitempty"`
	// Data source used to fetch values for a variable. It can be defined but `null`.
	Datasource *DataSourceRef `json:"datasource,omitempty"`
	// Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
	AllFormat *string `json:"allFormat,omitempty"`
	// Shows current selected variable text/value on the dashboard
	Current *VariableOption `json:"current,omitempty"`
	// Whether multiple values can be selected or not from variable value list
	Multi *bool `json:"multi,omitempty"`
	// Options that can be selected for a variable.
	Options []VariableOption `json:"options,omitempty"`
	// Options to config when to refresh a variable
	Refresh *VariableRefresh `json:"refresh,omitempty"`
	// Options sort order
	Sort *VariableSort `json:"sort,omitempty"`
	// Whether all value option is available or not
	IncludeAll *bool `json:"includeAll,omitempty"`
	// Custom all value
	AllValue *string `json:"allValue,omitempty"`
	// Optional field, if you want to extract part of a series name or metric node segment.
	// Named capture groups can be used to separate the display text and value.
	Regex *string `json:"regex,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `VariableModel` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *VariableModel) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "id"
	if fields["id"] != nil {
		if string(fields["id"]) != "null" {
			if err := json.Unmarshal(fields["id"], &resource.Id); err != nil {
				errs = append(errs, cog.MakeBuildErrors("id", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("id", errors.New("required field is null"))...)

		}
		delete(fields, "id")
	} else {
		errs = append(errs, cog.MakeBuildErrors("id", errors.New("required field is missing from input"))...)
	}
	// Field "type"
	if fields["type"] != nil {
		if string(fields["type"]) != "null" {
			if err := json.Unmarshal(fields["type"], &resource.Type); err != nil {
				errs = append(errs, cog.MakeBuildErrors("type", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is null"))...)

		}
		delete(fields, "type")
	} else {
		errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is missing from input"))...)
	}
	// Field "name"
	if fields["name"] != nil {
		if string(fields["name"]) != "null" {
			if err := json.Unmarshal(fields["name"], &resource.Name); err != nil {
				errs = append(errs, cog.MakeBuildErrors("name", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("name", errors.New("required field is null"))...)

		}
		delete(fields, "name")
	} else {
		errs = append(errs, cog.MakeBuildErrors("name", errors.New("required field is missing from input"))...)
	}
	// Field "label"
	if fields["label"] != nil {
		if string(fields["label"]) != "null" {
			if err := json.Unmarshal(fields["label"], &resource.Label); err != nil {
				errs = append(errs, cog.MakeBuildErrors("label", err)...)
			}

		}
		delete(fields, "label")

	}
	// Field "hide"
	if fields["hide"] != nil {
		if string(fields["hide"]) != "null" {
			if err := json.Unmarshal(fields["hide"], &resource.Hide); err != nil {
				errs = append(errs, cog.MakeBuildErrors("hide", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("hide", errors.New("required field is null"))...)

		}
		delete(fields, "hide")
	} else {
		errs = append(errs, cog.MakeBuildErrors("hide", errors.New("required field is missing from input"))...)
	}
	// Field "skipUrlSync"
	if fields["skipUrlSync"] != nil {
		if string(fields["skipUrlSync"]) != "null" {
			if err := json.Unmarshal(fields["skipUrlSync"], &resource.SkipUrlSync); err != nil {
				errs = append(errs, cog.MakeBuildErrors("skipUrlSync", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("skipUrlSync", errors.New("required field is null"))...)

		}
		delete(fields, "skipUrlSync")
	} else {
		errs = append(errs, cog.MakeBuildErrors("skipUrlSync", errors.New("required field is missing from input"))...)
	}
	// Field "description"
	if fields["description"] != nil {
		if string(fields["description"]) != "null" {
			if err := json.Unmarshal(fields["description"], &resource.Description); err != nil {
				errs = append(errs, cog.MakeBuildErrors("description", err)...)
			}

		}
		delete(fields, "description")

	}
	// Field "query"
	if fields["query"] != nil {
		if string(fields["query"]) != "null" {

			resource.Query = &StringOrMap{}
			if err := resource.Query.UnmarshalJSONStrict(fields["query"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("query", err)...)
			}

		}
		delete(fields, "query")

	}
	// Field "datasource"
	if fields["datasource"] != nil {
		if string(fields["datasource"]) != "null" {

			resource.Datasource = &DataSourceRef{}
			if err := resource.Datasource.UnmarshalJSONStrict(fields["datasource"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("datasource", err)...)
			}

		}
		delete(fields, "datasource")

	}
	// Field "allFormat"
	if fields["allFormat"] != nil {
		if string(fields["allFormat"]) != "null" {
			if err := json.Unmarshal(fields["allFormat"], &resource.AllFormat); err != nil {
				errs = append(errs, cog.MakeBuildErrors("allFormat", err)...)
			}

		}
		delete(fields, "allFormat")

	}
	// Field "current"
	if fields["current"] != nil {
		if string(fields["current"]) != "null" {

			resource.Current = &VariableOption{}
			if err := resource.Current.UnmarshalJSONStrict(fields["current"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("current", err)...)
			}

		}
		delete(fields, "current")

	}
	// Field "multi"
	if fields["multi"] != nil {
		if string(fields["multi"]) != "null" {
			if err := json.Unmarshal(fields["multi"], &resource.Multi); err != nil {
				errs = append(errs, cog.MakeBuildErrors("multi", err)...)
			}

		}
		delete(fields, "multi")

	}
	// Field "options"
	if fields["options"] != nil {
		if string(fields["options"]) != "null" {

			partialArray := []json.RawMessage{}
			if err := json.Unmarshal(fields["options"], &partialArray); err != nil {
				return err
			}

			for i1 := range partialArray {
				var result1 VariableOption

				result1 = VariableOption{}
				if err := result1.UnmarshalJSONStrict(partialArray[i1]); err != nil {
					errs = append(errs, cog.MakeBuildErrors("options["+strconv.Itoa(i1)+"]", err)...)
				}
				resource.Options = append(resource.Options, result1)
			}

		}
		delete(fields, "options")

	}
	// Field "refresh"
	if fields["refresh"] != nil {
		if string(fields["refresh"]) != "null" {
			if err := json.Unmarshal(fields["refresh"], &resource.Refresh); err != nil {
				errs = append(errs, cog.MakeBuildErrors("refresh", err)...)
			}

		}
		delete(fields, "refresh")

	}
	// Field "sort"
	if fields["sort"] != nil {
		if string(fields["sort"]) != "null" {
			if err := json.Unmarshal(fields["sort"], &resource.Sort); err != nil {
				errs = append(errs, cog.MakeBuildErrors("sort", err)...)
			}

		}
		delete(fields, "sort")

	}
	// Field "includeAll"
	if fields["includeAll"] != nil {
		if string(fields["includeAll"]) != "null" {
			if err := json.Unmarshal(fields["includeAll"], &resource.IncludeAll); err != nil {
				errs = append(errs, cog.MakeBuildErrors("includeAll", err)...)
			}

		}
		delete(fields, "includeAll")

	}
	// Field "allValue"
	if fields["allValue"] != nil {
		if string(fields["allValue"]) != "null" {
			if err := json.Unmarshal(fields["allValue"], &resource.AllValue); err != nil {
				errs = append(errs, cog.MakeBuildErrors("allValue", err)...)
			}

		}
		delete(fields, "allValue")

	}
	// Field "regex"
	if fields["regex"] != nil {
		if string(fields["regex"]) != "null" {
			if err := json.Unmarshal(fields["regex"], &resource.Regex); err != nil {
				errs = append(errs, cog.MakeBuildErrors("regex", err)...)
			}

		}
		delete(fields, "regex")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("VariableModel", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `VariableModel` objects.
func (resource VariableModel) Equals(other VariableModel) bool {
	if resource.Id != other.Id {
		return false
	}
	if resource.Type != other.Type {
		return false
	}
	if resource.Name != other.Name {
		return false
	}
	if resource.Label == nil && other.Label != nil || resource.Label != nil && other.Label == nil {
		return false
	}

	if resource.Label != nil {
		if *resource.Label != *other.Label {
			return false
		}
	}
	if resource.Hide != other.Hide {
		return false
	}
	if resource.SkipUrlSync != other.SkipUrlSync {
		return false
	}
	if resource.Description == nil && other.Description != nil || resource.Description != nil && other.Description == nil {
		return false
	}

	if resource.Description != nil {
		if *resource.Description != *other.Description {
			return false
		}
	}
	if resource.Query == nil && other.Query != nil || resource.Query != nil && other.Query == nil {
		return false
	}

	if resource.Query != nil {
		if !resource.Query.Equals(*other.Query) {
			return false
		}
	}
	if resource.Datasource == nil && other.Datasource != nil || resource.Datasource != nil && other.Datasource == nil {
		return false
	}

	if resource.Datasource != nil {
		if !resource.Datasource.Equals(*other.Datasource) {
			return false
		}
	}
	if resource.AllFormat == nil && other.AllFormat != nil || resource.AllFormat != nil && other.AllFormat == nil {
		return false
	}

	if resource.AllFormat != nil {
		if *resource.AllFormat != *other.AllFormat {
			return false
		}
	}
	if resource.Current == nil && other.Current != nil || resource.Current != nil && other.Current == nil {
		return false
	}

	if resource.Current != nil {
		if !resource.Current.Equals(*other.Current) {
			return false
		}
	}
	if resource.Multi == nil && other.Multi != nil || resource.Multi != nil && other.Multi == nil {
		return false
	}

	if resource.Multi != nil {
		if *resource.Multi != *other.Multi {
			return false
		}
	}

	if len(resource.Options) != len(other.Options) {
		return false
	}

	for i1 := range resource.Options {
		if !resource.Options[i1].Equals(other.Options[i1]) {
			return false
		}
	}
	if resource.Refresh == nil && other.Refresh != nil || resource.Refresh != nil && other.Refresh == nil {
		return false
	}

	if resource.Refresh != nil {
		if *resource.Refresh != *other.Refresh {
			return false
		}
	}
	if resource.Sort == nil && other.Sort != nil || resource.Sort != nil && other.Sort == nil {
		return false
	}

	if resource.Sort != nil {
		if *resource.Sort != *other.Sort {
			return false
		}
	}
	if resource.IncludeAll == nil && other.IncludeAll != nil || resource.IncludeAll != nil && other.IncludeAll == nil {
		return false
	}

	if resource.IncludeAll != nil {
		if *resource.IncludeAll != *other.IncludeAll {
			return false
		}
	}
	if resource.AllValue == nil && other.AllValue != nil || resource.AllValue != nil && other.AllValue == nil {
		return false
	}

	if resource.AllValue != nil {
		if *resource.AllValue != *other.AllValue {
			return false
		}
	}
	if resource.Regex == nil && other.Regex != nil || resource.Regex != nil && other.Regex == nil {
		return false
	}

	if resource.Regex != nil {
		if *resource.Regex != *other.Regex {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `VariableModel` fields for violations and returns them.
func (resource VariableModel) Validate() error {
	var errs cog.BuildErrors
	if resource.Query != nil {
		if err := resource.Query.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("query", err)...)
		}
	}
	if resource.Datasource != nil {
		if err := resource.Datasource.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("datasource", err)...)
		}
	}
	if resource.Current != nil {
		if err := resource.Current.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("current", err)...)
		}
	}

	for i1 := range resource.Options {
		if err := resource.Options[i1].Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("options["+strconv.Itoa(i1)+"]", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Option to be selected in a variable.
type VariableOption struct {
	// Whether the option is selected or not
	Selected *bool `json:"selected,omitempty"`
	// Text to be displayed for the option
	Text StringOrArrayOfString `json:"text"`
	// Value of the option
	Value StringOrArrayOfString `json:"value"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `VariableOption` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *VariableOption) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "selected"
	if fields["selected"] != nil {
		if string(fields["selected"]) != "null" {
			if err := json.Unmarshal(fields["selected"], &resource.Selected); err != nil {
				errs = append(errs, cog.MakeBuildErrors("selected", err)...)
			}

		}
		delete(fields, "selected")

	}
	// Field "text"
	if fields["text"] != nil {
		if string(fields["text"]) != "null" {

			resource.Text = StringOrArrayOfString{}
			if err := resource.Text.UnmarshalJSONStrict(fields["text"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("text", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("text", errors.New("required field is null"))...)

		}
		delete(fields, "text")
	} else {
		errs = append(errs, cog.MakeBuildErrors("text", errors.New("required field is missing from input"))...)
	}
	// Field "value"
	if fields["value"] != nil {
		if string(fields["value"]) != "null" {

			resource.Value = StringOrArrayOfString{}
			if err := resource.Value.UnmarshalJSONStrict(fields["value"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("value", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("value", errors.New("required field is null"))...)

		}
		delete(fields, "value")
	} else {
		errs = append(errs, cog.MakeBuildErrors("value", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("VariableOption", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `VariableOption` objects.
func (resource VariableOption) Equals(other VariableOption) bool {
	if resource.Selected == nil && other.Selected != nil || resource.Selected != nil && other.Selected == nil {
		return false
	}

	if resource.Selected != nil {
		if *resource.Selected != *other.Selected {
			return false
		}
	}
	if !resource.Text.Equals(other.Text) {
		return false
	}
	if !resource.Value.Equals(other.Value) {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `VariableOption` fields for violations and returns them.
func (resource VariableOption) Validate() error {
	var errs cog.BuildErrors
	if err := resource.Text.Validate(); err != nil {
		errs = append(errs, cog.MakeBuildErrors("text", err)...)
	}
	if err := resource.Value.Validate(); err != nil {
		errs = append(errs, cog.MakeBuildErrors("value", err)...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Options to config when to refresh a variable
// `0`: Never refresh the variable
// `1`: Queries the data source every time the dashboard loads.
// `2`: Queries the data source when the dashboard time range changes.
type VariableRefresh int64

const (
	VariableRefreshNever              VariableRefresh = 0
	VariableRefreshOnDashboardLoad    VariableRefresh = 1
	VariableRefreshOnTimeRangeChanged VariableRefresh = 2
)

// Determine if the variable shows on dashboard
// Accepted values are 0 (show label and value), 1 (show value only), 2 (show nothing).
type VariableHide int64

const (
	VariableHideDontHide     VariableHide = 0
	VariableHideHideLabel    VariableHide = 1
	VariableHideHideVariable VariableHide = 2
)

// Sort variable options
// Accepted values are:
// `0`: No sorting
// `1`: Alphabetical ASC
// `2`: Alphabetical DESC
// `3`: Numerical ASC
// `4`: Numerical DESC
// `5`: Alphabetical Case Insensitive ASC
// `6`: Alphabetical Case Insensitive DESC
type VariableSort int64

const (
	VariableSortDisabled                        VariableSort = 0
	VariableSortAlphabeticalAsc                 VariableSort = 1
	VariableSortAlphabeticalDesc                VariableSort = 2
	VariableSortNumericalAsc                    VariableSort = 3
	VariableSortNumericalDesc                   VariableSort = 4
	VariableSortAlphabeticalCaseInsensitiveAsc  VariableSort = 5
	VariableSortAlphabeticalCaseInsensitiveDesc VariableSort = 6
)

// Loading status
// Accepted values are `NotStarted` (the request is not started), `Loading` (waiting for response), `Streaming` (pulling continuous data), `Done` (response received successfully) or `Error` (failed request).
type LoadingState string

const (
	LoadingStateNotStarted LoadingState = "NotStarted"
	LoadingStateLoading    LoadingState = "Loading"
	LoadingStateStreaming  LoadingState = "Streaming"
	LoadingStateDone       LoadingState = "Done"
	LoadingStateError      LoadingState = "Error"
)

// Ref to a DataSource instance
type DataSourceRef struct {
	// The plugin type-id
	Type *string `json:"type,omitempty"`
	// Specific datasource instance
	Uid *string `json:"uid,omitempty"`
}

func (resource *DataSourceRef) UnmarshalJSON(raw []byte) error {
	if raw == nil {
		return nil
	}

	if raw[0] == '"' {
		var datasourceUid string
		if err := json.Unmarshal(raw, &datasourceUid); err != nil {
			return err
		}
		resource.Uid = &datasourceUid
	} else {
		type original DataSourceRef

		if err := json.Unmarshal(raw, (*original)(resource)); err != nil {
			return err
		}
	}

	return nil
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `DataSourceRef` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *DataSourceRef) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "type"
	if fields["type"] != nil {
		if string(fields["type"]) != "null" {
			if err := json.Unmarshal(fields["type"], &resource.Type); err != nil {
				errs = append(errs, cog.MakeBuildErrors("type", err)...)
			}

		}
		delete(fields, "type")

	}
	// Field "uid"
	if fields["uid"] != nil {
		if string(fields["uid"]) != "null" {
			if err := json.Unmarshal(fields["uid"], &resource.Uid); err != nil {
				errs = append(errs, cog.MakeBuildErrors("uid", err)...)
			}

		}
		delete(fields, "uid")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("DataSourceRef", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `DataSourceRef` objects.
func (resource DataSourceRef) Equals(other DataSourceRef) bool {
	if resource.Type == nil && other.Type != nil || resource.Type != nil && other.Type == nil {
		return false
	}

	if resource.Type != nil {
		if *resource.Type != *other.Type {
			return false
		}
	}
	if resource.Uid == nil && other.Uid != nil || resource.Uid != nil && other.Uid == nil {
		return false
	}

	if resource.Uid != nil {
		if *resource.Uid != *other.Uid {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `DataSourceRef` fields for violations and returns them.
func (resource DataSourceRef) Validate() error {
	return nil
}

// Links with references to other dashboards or external resources
type DashboardLink struct {
	// Title to display with the link
	Title string `json:"title"`
	// Link type. Accepted values are dashboards (to refer to another dashboard) and link (to refer to an external resource)
	Type DashboardLinkType `json:"type"`
	// Icon name to be displayed with the link
	Icon string `json:"icon"`
	// Tooltip to display when the user hovers their mouse over it
	Tooltip string `json:"tooltip"`
	// Link URL. Only required/valid if the type is link
	Url string `json:"url"`
	// List of tags to limit the linked dashboards. If empty, all dashboards will be displayed. Only valid if the type is dashboards
	Tags []string `json:"tags"`
	// If true, all dashboards links will be displayed in a dropdown. If false, all dashboards links will be displayed side by side. Only valid if the type is dashboards
	AsDropdown bool `json:"asDropdown"`
	// If true, the link will be opened in a new tab
	TargetBlank bool `json:"targetBlank"`
	// If true, includes current template variables values in the link as query params
	IncludeVars bool `json:"includeVars"`
	// If true, includes current time range in the link as query params
	KeepTime bool `json:"keepTime"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `DashboardLink` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *DashboardLink) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "title"
	if fields["title"] != nil {
		if string(fields["title"]) != "null" {
			if err := json.Unmarshal(fields["title"], &resource.Title); err != nil {
				errs = append(errs, cog.MakeBuildErrors("title", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("title", errors.New("required field is null"))...)

		}
		delete(fields, "title")
	} else {
		errs = append(errs, cog.MakeBuildErrors("title", errors.New("required field is missing from input"))...)
	}
	// Field "type"
	if fields["type"] != nil {
		if string(fields["type"]) != "null" {
			if err := json.Unmarshal(fields["type"], &resource.Type); err != nil {
				errs = append(errs, cog.MakeBuildErrors("type", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is null"))...)

		}
		delete(fields, "type")
	} else {
		errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is missing from input"))...)
	}
	// Field "icon"
	if fields["icon"] != nil {
		if string(fields["icon"]) != "null" {
			if err := json.Unmarshal(fields["icon"], &resource.Icon); err != nil {
				errs = append(errs, cog.MakeBuildErrors("icon", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("icon", errors.New("required field is null"))...)

		}
		delete(fields, "icon")
	} else {
		errs = append(errs, cog.MakeBuildErrors("icon", errors.New("required field is missing from input"))...)
	}
	// Field "tooltip"
	if fields["tooltip"] != nil {
		if string(fields["tooltip"]) != "null" {
			if err := json.Unmarshal(fields["tooltip"], &resource.Tooltip); err != nil {
				errs = append(errs, cog.MakeBuildErrors("tooltip", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("tooltip", errors.New("required field is null"))...)

		}
		delete(fields, "tooltip")
	} else {
		errs = append(errs, cog.MakeBuildErrors("tooltip", errors.New("required field is missing from input"))...)
	}
	// Field "url"
	if fields["url"] != nil {
		if string(fields["url"]) != "null" {
			if err := json.Unmarshal(fields["url"], &resource.Url); err != nil {
				errs = append(errs, cog.MakeBuildErrors("url", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("url", errors.New("required field is null"))...)

		}
		delete(fields, "url")
	} else {
		errs = append(errs, cog.MakeBuildErrors("url", errors.New("required field is missing from input"))...)
	}
	// Field "tags"
	if fields["tags"] != nil {
		if string(fields["tags"]) != "null" {

			if err := json.Unmarshal(fields["tags"], &resource.Tags); err != nil {
				errs = append(errs, cog.MakeBuildErrors("tags", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("tags", errors.New("required field is null"))...)

		}
		delete(fields, "tags")
	} else {
		errs = append(errs, cog.MakeBuildErrors("tags", errors.New("required field is missing from input"))...)
	}
	// Field "asDropdown"
	if fields["asDropdown"] != nil {
		if string(fields["asDropdown"]) != "null" {
			if err := json.Unmarshal(fields["asDropdown"], &resource.AsDropdown); err != nil {
				errs = append(errs, cog.MakeBuildErrors("asDropdown", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("asDropdown", errors.New("required field is null"))...)

		}
		delete(fields, "asDropdown")
	} else {
		errs = append(errs, cog.MakeBuildErrors("asDropdown", errors.New("required field is missing from input"))...)
	}
	// Field "targetBlank"
	if fields["targetBlank"] != nil {
		if string(fields["targetBlank"]) != "null" {
			if err := json.Unmarshal(fields["targetBlank"], &resource.TargetBlank); err != nil {
				errs = append(errs, cog.MakeBuildErrors("targetBlank", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("targetBlank", errors.New("required field is null"))...)

		}
		delete(fields, "targetBlank")
	} else {
		errs = append(errs, cog.MakeBuildErrors("targetBlank", errors.New("required field is missing from input"))...)
	}
	// Field "includeVars"
	if fields["includeVars"] != nil {
		if string(fields["includeVars"]) != "null" {
			if err := json.Unmarshal(fields["includeVars"], &resource.IncludeVars); err != nil {
				errs = append(errs, cog.MakeBuildErrors("includeVars", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("includeVars", errors.New("required field is null"))...)

		}
		delete(fields, "includeVars")
	} else {
		errs = append(errs, cog.MakeBuildErrors("includeVars", errors.New("required field is missing from input"))...)
	}
	// Field "keepTime"
	if fields["keepTime"] != nil {
		if string(fields["keepTime"]) != "null" {
			if err := json.Unmarshal(fields["keepTime"], &resource.KeepTime); err != nil {
				errs = append(errs, cog.MakeBuildErrors("keepTime", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("keepTime", errors.New("required field is null"))...)

		}
		delete(fields, "keepTime")
	} else {
		errs = append(errs, cog.MakeBuildErrors("keepTime", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("DashboardLink", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `DashboardLink` objects.
func (resource DashboardLink) Equals(other DashboardLink) bool {
	if resource.Title != other.Title {
		return false
	}
	if resource.Type != other.Type {
		return false
	}
	if resource.Icon != other.Icon {
		return false
	}
	if resource.Tooltip != other.Tooltip {
		return false
	}
	if resource.Url != other.Url {
		return false
	}

	if len(resource.Tags) != len(other.Tags) {
		return false
	}

	for i1 := range resource.Tags {
		if resource.Tags[i1] != other.Tags[i1] {
			return false
		}
	}
	if resource.AsDropdown != other.AsDropdown {
		return false
	}
	if resource.TargetBlank != other.TargetBlank {
		return false
	}
	if resource.IncludeVars != other.IncludeVars {
		return false
	}
	if resource.KeepTime != other.KeepTime {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `DashboardLink` fields for violations and returns them.
func (resource DashboardLink) Validate() error {
	return nil
}

// Dashboard Link type. Accepted values are dashboards (to refer to another dashboard) and link (to refer to an external resource)
type DashboardLinkType string

const (
	DashboardLinkTypeLink       DashboardLinkType = "link"
	DashboardLinkTypeDashboards DashboardLinkType = "dashboards"
)

// Dashboard variable type
// `query`: Query-generated list of values such as metric names, server names, sensor IDs, data centers, and so on.
// `adhoc`: Key/value filters that are automatically added to all metric queries for a data source (Prometheus, Loki, InfluxDB, and Elasticsearch only).
// `constant`: 	Define a hidden constant.
// `datasource`: Quickly change the data source for an entire dashboard.
// `interval`: Interval variables represent time spans.
// `textbox`: Display a free text input field with an optional default value.
// `custom`: Define the variable options manually using a comma-separated list.
// `system`: Variables defined by Grafana. See: https://grafana.com/docs/grafana/latest/dashboards/variables/add-template-variables/#global-variables
type VariableType string

const (
	VariableTypeQuery      VariableType = "query"
	VariableTypeAdhoc      VariableType = "adhoc"
	VariableTypeConstant   VariableType = "constant"
	VariableTypeDatasource VariableType = "datasource"
	VariableTypeInterval   VariableType = "interval"
	VariableTypeTextbox    VariableType = "textbox"
	VariableTypeCustom     VariableType = "custom"
	VariableTypeSystem     VariableType = "system"
)

// Color mode for a field. You can specify a single color, or select a continuous (gradient) color schemes, based on a value.
// Continuous color interpolates a color using the percentage of a value relative to min and max.
// Accepted values are:
// `thresholds`: From thresholds. Informs Grafana to take the color from the matching threshold
// `palette-classic`: Classic palette. Grafana will assign color by looking up a color in a palette by series index. Useful for Graphs and pie charts and other categorical data visualizations
// `palette-classic-by-name`: Classic palette (by name). Grafana will assign color by looking up a color in a palette by series name. Useful for Graphs and pie charts and other categorical data visualizations
// `continuous-GrYlRd`: ontinuous Green-Yellow-Red palette mode
// `continuous-RdYlGr`: Continuous Red-Yellow-Green palette mode
// `continuous-BlYlRd`: Continuous Blue-Yellow-Red palette mode
// `continuous-YlRd`: Continuous Yellow-Red palette mode
// `continuous-BlPu`: Continuous Blue-Purple palette mode
// `continuous-YlBl`: Continuous Yellow-Blue palette mode
// `continuous-blues`: Continuous Blue palette mode
// `continuous-reds`: Continuous Red palette mode
// `continuous-greens`: Continuous Green palette mode
// `continuous-purples`: Continuous Purple palette mode
// `shades`: Shades of a single color. Specify a single color, useful in an override rule.
// `fixed`: Fixed color mode. Specify a single color, useful in an override rule.
type FieldColorModeId string

const (
	FieldColorModeIdThresholds           FieldColorModeId = "thresholds"
	FieldColorModeIdPaletteClassic       FieldColorModeId = "palette-classic"
	FieldColorModeIdPaletteClassicByName FieldColorModeId = "palette-classic-by-name"
	FieldColorModeIdContinuousGrYlRd     FieldColorModeId = "continuous-GrYlRd"
	FieldColorModeIdContinuousRdYlGr     FieldColorModeId = "continuous-RdYlGr"
	FieldColorModeIdContinuousBlYlRd     FieldColorModeId = "continuous-BlYlRd"
	FieldColorModeIdContinuousYlRd       FieldColorModeId = "continuous-YlRd"
	FieldColorModeIdContinuousBlPu       FieldColorModeId = "continuous-BlPu"
	FieldColorModeIdContinuousYlBl       FieldColorModeId = "continuous-YlBl"
	FieldColorModeIdContinuousBlues      FieldColorModeId = "continuous-blues"
	FieldColorModeIdContinuousReds       FieldColorModeId = "continuous-reds"
	FieldColorModeIdContinuousGreens     FieldColorModeId = "continuous-greens"
	FieldColorModeIdContinuousPurples    FieldColorModeId = "continuous-purples"
	FieldColorModeIdFixed                FieldColorModeId = "fixed"
	FieldColorModeIdShades               FieldColorModeId = "shades"
)

// Defines how to assign a series color from "by value" color schemes. For example for an aggregated data points like a timeseries, the color can be assigned by the min, max or last value.
type FieldColorSeriesByMode string

const (
	FieldColorSeriesByModeMin  FieldColorSeriesByMode = "min"
	FieldColorSeriesByModeMax  FieldColorSeriesByMode = "max"
	FieldColorSeriesByModeLast FieldColorSeriesByMode = "last"
)

// Map a field to a color.
type FieldColor struct {
	// The main color scheme mode.
	Mode FieldColorModeId `json:"mode"`
	// The fixed color value for fixed or shades color modes.
	FixedColor *string `json:"fixedColor,omitempty"`
	// Some visualizations need to know how to assign a series color from by value color schemes.
	SeriesBy *FieldColorSeriesByMode `json:"seriesBy,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `FieldColor` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *FieldColor) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "mode"
	if fields["mode"] != nil {
		if string(fields["mode"]) != "null" {
			if err := json.Unmarshal(fields["mode"], &resource.Mode); err != nil {
				errs = append(errs, cog.MakeBuildErrors("mode", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("mode", errors.New("required field is null"))...)

		}
		delete(fields, "mode")
	} else {
		errs = append(errs, cog.MakeBuildErrors("mode", errors.New("required field is missing from input"))...)
	}
	// Field "fixedColor"
	if fields["fixedColor"] != nil {
		if string(fields["fixedColor"]) != "null" {
			if err := json.Unmarshal(fields["fixedColor"], &resource.FixedColor); err != nil {
				errs = append(errs, cog.MakeBuildErrors("fixedColor", err)...)
			}

		}
		delete(fields, "fixedColor")

	}
	// Field "seriesBy"
	if fields["seriesBy"] != nil {
		if string(fields["seriesBy"]) != "null" {
			if err := json.Unmarshal(fields["seriesBy"], &resource.SeriesBy); err != nil {
				errs = append(errs, cog.MakeBuildErrors("seriesBy", err)...)
			}

		}
		delete(fields, "seriesBy")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("FieldColor", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `FieldColor` objects.
func (resource FieldColor) Equals(other FieldColor) bool {
	if resource.Mode != other.Mode {
		return false
	}
	if resource.FixedColor == nil && other.FixedColor != nil || resource.FixedColor != nil && other.FixedColor == nil {
		return false
	}

	if resource.FixedColor != nil {
		if *resource.FixedColor != *other.FixedColor {
			return false
		}
	}
	if resource.SeriesBy == nil && other.SeriesBy != nil || resource.SeriesBy != nil && other.SeriesBy == nil {
		return false
	}

	if resource.SeriesBy != nil {
		if *resource.SeriesBy != *other.SeriesBy {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `FieldColor` fields for violations and returns them.
func (resource FieldColor) Validate() error {
	return nil
}

// Position and dimensions of a panel in the grid
type GridPos struct {
	// Panel height. The height is the number of rows from the top edge of the panel.
	H uint32 `json:"h"`
	// Panel width. The width is the number of columns from the left edge of the panel.
	W uint32 `json:"w"`
	// Panel x. The x coordinate is the number of columns from the left edge of the grid
	X uint32 `json:"x"`
	// Panel y. The y coordinate is the number of rows from the top edge of the grid
	Y uint32 `json:"y"`
	// Whether the panel is fixed within the grid. If true, the panel will not be affected by other panels' interactions
	Static *bool `json:"static,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `GridPos` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *GridPos) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "h"
	if fields["h"] != nil {
		if string(fields["h"]) != "null" {
			if err := json.Unmarshal(fields["h"], &resource.H); err != nil {
				errs = append(errs, cog.MakeBuildErrors("h", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("h", errors.New("required field is null"))...)

		}
		delete(fields, "h")
	} else {
		errs = append(errs, cog.MakeBuildErrors("h", errors.New("required field is missing from input"))...)
	}
	// Field "w"
	if fields["w"] != nil {
		if string(fields["w"]) != "null" {
			if err := json.Unmarshal(fields["w"], &resource.W); err != nil {
				errs = append(errs, cog.MakeBuildErrors("w", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("w", errors.New("required field is null"))...)

		}
		delete(fields, "w")
	} else {
		errs = append(errs, cog.MakeBuildErrors("w", errors.New("required field is missing from input"))...)
	}
	// Field "x"
	if fields["x"] != nil {
		if string(fields["x"]) != "null" {
			if err := json.Unmarshal(fields["x"], &resource.X); err != nil {
				errs = append(errs, cog.MakeBuildErrors("x", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("x", errors.New("required field is null"))...)

		}
		delete(fields, "x")
	} else {
		errs = append(errs, cog.MakeBuildErrors("x", errors.New("required field is missing from input"))...)
	}
	// Field "y"
	if fields["y"] != nil {
		if string(fields["y"]) != "null" {
			if err := json.Unmarshal(fields["y"], &resource.Y); err != nil {
				errs = append(errs, cog.MakeBuildErrors("y", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("y", errors.New("required field is null"))...)

		}
		delete(fields, "y")
	} else {
		errs = append(errs, cog.MakeBuildErrors("y", errors.New("required field is missing from input"))...)
	}
	// Field "static"
	if fields["static"] != nil {
		if string(fields["static"]) != "null" {
			if err := json.Unmarshal(fields["static"], &resource.Static); err != nil {
				errs = append(errs, cog.MakeBuildErrors("static", err)...)
			}

		}
		delete(fields, "static")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("GridPos", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `GridPos` objects.
func (resource GridPos) Equals(other GridPos) bool {
	if resource.H != other.H {
		return false
	}
	if resource.W != other.W {
		return false
	}
	if resource.X != other.X {
		return false
	}
	if resource.Y != other.Y {
		return false
	}
	if resource.Static == nil && other.Static != nil || resource.Static != nil && other.Static == nil {
		return false
	}

	if resource.Static != nil {
		if *resource.Static != *other.Static {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `GridPos` fields for violations and returns them.
func (resource GridPos) Validate() error {
	var errs cog.BuildErrors
	if !(resource.H > 0) {
		errs = append(errs, cog.MakeBuildErrors(
			"h",
			errors.New("must be > 0"),
		)...)
	}
	if !(resource.W > 0) {
		errs = append(errs, cog.MakeBuildErrors(
			"w",
			errors.New("must be > 0"),
		)...)
	}
	if !(resource.W <= 24) {
		errs = append(errs, cog.MakeBuildErrors(
			"w",
			errors.New("must be <= 24"),
		)...)
	}
	if !(resource.X < 24) {
		errs = append(errs, cog.MakeBuildErrors(
			"x",
			errors.New("must be < 24"),
		)...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// User-defined value for a metric that triggers visual changes in a panel when this value is met or exceeded
// They are used to conditionally style and color visualizations based on query results , and can be applied to most visualizations.
type Threshold struct {
	// Value represents a specified metric for the threshold, which triggers a visual change in the dashboard when this value is met or exceeded.
	// Nulls currently appear here when serializing -Infinity to JSON.
	Value *float64 `json:"value"`
	// Color represents the color of the visual change that will occur in the dashboard when the threshold value is met or exceeded.
	Color string `json:"color"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `Threshold` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *Threshold) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "value"
	if fields["value"] != nil {
		if string(fields["value"]) != "null" {
			if err := json.Unmarshal(fields["value"], &resource.Value); err != nil {
				errs = append(errs, cog.MakeBuildErrors("value", err)...)
			}

		}
		delete(fields, "value")
	} else {
		errs = append(errs, cog.MakeBuildErrors("value", errors.New("required field is missing from input"))...)
	}
	// Field "color"
	if fields["color"] != nil {
		if string(fields["color"]) != "null" {
			if err := json.Unmarshal(fields["color"], &resource.Color); err != nil {
				errs = append(errs, cog.MakeBuildErrors("color", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("color", errors.New("required field is null"))...)

		}
		delete(fields, "color")
	} else {
		errs = append(errs, cog.MakeBuildErrors("color", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("Threshold", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `Threshold` objects.
func (resource Threshold) Equals(other Threshold) bool {
	if resource.Value == nil && other.Value != nil || resource.Value != nil && other.Value == nil {
		return false
	}

	if resource.Value != nil {
		if *resource.Value != *other.Value {
			return false
		}
	}
	if resource.Color != other.Color {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `Threshold` fields for violations and returns them.
func (resource Threshold) Validate() error {
	return nil
}

// Thresholds can either be `absolute` (specific number) or `percentage` (relative to min or max, it will be values between 0 and 1).
type ThresholdsMode string

const (
	ThresholdsModeAbsolute   ThresholdsMode = "absolute"
	ThresholdsModePercentage ThresholdsMode = "percentage"
)

// Thresholds configuration for the panel
type ThresholdsConfig struct {
	// Thresholds mode.
	Mode ThresholdsMode `json:"mode"`
	// Must be sorted by 'value', first value is always -Infinity
	Steps []Threshold `json:"steps"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `ThresholdsConfig` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *ThresholdsConfig) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "mode"
	if fields["mode"] != nil {
		if string(fields["mode"]) != "null" {
			if err := json.Unmarshal(fields["mode"], &resource.Mode); err != nil {
				errs = append(errs, cog.MakeBuildErrors("mode", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("mode", errors.New("required field is null"))...)

		}
		delete(fields, "mode")
	} else {
		errs = append(errs, cog.MakeBuildErrors("mode", errors.New("required field is missing from input"))...)
	}
	// Field "steps"
	if fields["steps"] != nil {
		if string(fields["steps"]) != "null" {

			partialArray := []json.RawMessage{}
			if err := json.Unmarshal(fields["steps"], &partialArray); err != nil {
				return err
			}

			for i1 := range partialArray {
				var result1 Threshold

				result1 = Threshold{}
				if err := result1.UnmarshalJSONStrict(partialArray[i1]); err != nil {
					errs = append(errs, cog.MakeBuildErrors("steps["+strconv.Itoa(i1)+"]", err)...)
				}
				resource.Steps = append(resource.Steps, result1)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("steps", errors.New("required field is null"))...)

		}
		delete(fields, "steps")
	} else {
		errs = append(errs, cog.MakeBuildErrors("steps", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("ThresholdsConfig", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `ThresholdsConfig` objects.
func (resource ThresholdsConfig) Equals(other ThresholdsConfig) bool {
	if resource.Mode != other.Mode {
		return false
	}

	if len(resource.Steps) != len(other.Steps) {
		return false
	}

	for i1 := range resource.Steps {
		if !resource.Steps[i1].Equals(other.Steps[i1]) {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `ThresholdsConfig` fields for violations and returns them.
func (resource ThresholdsConfig) Validate() error {
	var errs cog.BuildErrors

	for i1 := range resource.Steps {
		if err := resource.Steps[i1].Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("steps["+strconv.Itoa(i1)+"]", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Allow to transform the visual representation of specific data values in a visualization, irrespective of their original units
type ValueMapping = ValueMapOrRangeMapOrRegexMapOrSpecialValueMap

// Supported value mapping types
// `value`: Maps text values to a color or different display text and color. For example, you can configure a value mapping so that all instances of the value 10 appear as Perfection! rather than the number.
// `range`: Maps numerical ranges to a display text and color. For example, if a value is within a certain range, you can configure a range value mapping to display Low or High rather than the number.
// `regex`: Maps regular expressions to replacement text and a color. For example, if a value is www.example.com, you can configure a regex value mapping so that Grafana displays www and truncates the domain.
// `special`: Maps special values like Null, NaN (not a number), and boolean values like true and false to a display text and color. See SpecialValueMatch to see the list of special values. For example, you can configure a special value mapping so that null values appear as N/A.
type MappingType string

const (
	MappingTypeValueToText  MappingType = "value"
	MappingTypeRangeToText  MappingType = "range"
	MappingTypeRegexToText  MappingType = "regex"
	MappingTypeSpecialValue MappingType = "special"
)

// Maps text values to a color or different display text and color.
// For example, you can configure a value mapping so that all instances of the value 10 appear as Perfection! rather than the number.
type ValueMap struct {
	Type string `json:"type"`
	// Map with <value_to_match>: ValueMappingResult. For example: { "10": { text: "Perfection!", color: "green" } }
	Options map[string]ValueMappingResult `json:"options"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `ValueMap` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *ValueMap) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "type"
	if fields["type"] != nil {
		if string(fields["type"]) != "null" {
			if err := json.Unmarshal(fields["type"], &resource.Type); err != nil {
				errs = append(errs, cog.MakeBuildErrors("type", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is null"))...)

		}
		delete(fields, "type")
	} else {
		errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is missing from input"))...)
	}
	// Field "options"
	if fields["options"] != nil {
		if string(fields["options"]) != "null" {

			partialMap := make(map[string]json.RawMessage)
			if err := json.Unmarshal(fields["options"], &partialMap); err != nil {
				return err
			}
			parsedMap1 := make(map[string]ValueMappingResult, len(partialMap))
			for key1 := range partialMap {
				var result1 ValueMappingResult

				result1 = ValueMappingResult{}
				if err := result1.UnmarshalJSONStrict(partialMap[key1]); err != nil {
					errs = append(errs, cog.MakeBuildErrors("options["+key1+"]", err)...)
				}
				parsedMap1[key1] = result1
			}
			resource.Options = parsedMap1
		} else {
			errs = append(errs, cog.MakeBuildErrors("options", errors.New("required field is null"))...)

		}
		delete(fields, "options")
	} else {
		errs = append(errs, cog.MakeBuildErrors("options", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("ValueMap", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `ValueMap` objects.
func (resource ValueMap) Equals(other ValueMap) bool {
	if resource.Type != other.Type {
		return false
	}

	if len(resource.Options) != len(other.Options) {
		return false
	}

	for key1 := range resource.Options {
		if !resource.Options[key1].Equals(other.Options[key1]) {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `ValueMap` fields for violations and returns them.
func (resource ValueMap) Validate() error {
	var errs cog.BuildErrors
	if !(resource.Type == "value") {
		errs = append(errs, cog.MakeBuildErrors(
			"type",
			errors.New("must be == value"),
		)...)
	}

	for key1 := range resource.Options {
		if err := resource.Options[key1].Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("options["+key1+"]", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Maps numerical ranges to a display text and color.
// For example, if a value is within a certain range, you can configure a range value mapping to display Low or High rather than the number.
type RangeMap struct {
	Type string `json:"type"`
	// Range to match against and the result to apply when the value is within the range
	Options DashboardRangeMapOptions `json:"options"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `RangeMap` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *RangeMap) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "type"
	if fields["type"] != nil {
		if string(fields["type"]) != "null" {
			if err := json.Unmarshal(fields["type"], &resource.Type); err != nil {
				errs = append(errs, cog.MakeBuildErrors("type", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is null"))...)

		}
		delete(fields, "type")
	} else {
		errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is missing from input"))...)
	}
	// Field "options"
	if fields["options"] != nil {
		if string(fields["options"]) != "null" {

			resource.Options = DashboardRangeMapOptions{}
			if err := resource.Options.UnmarshalJSONStrict(fields["options"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("options", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("options", errors.New("required field is null"))...)

		}
		delete(fields, "options")
	} else {
		errs = append(errs, cog.MakeBuildErrors("options", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("RangeMap", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `RangeMap` objects.
func (resource RangeMap) Equals(other RangeMap) bool {
	if resource.Type != other.Type {
		return false
	}
	if !resource.Options.Equals(other.Options) {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `RangeMap` fields for violations and returns them.
func (resource RangeMap) Validate() error {
	var errs cog.BuildErrors
	if !(resource.Type == "range") {
		errs = append(errs, cog.MakeBuildErrors(
			"type",
			errors.New("must be == range"),
		)...)
	}
	if err := resource.Options.Validate(); err != nil {
		errs = append(errs, cog.MakeBuildErrors("options", err)...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Maps regular expressions to replacement text and a color.
// For example, if a value is www.example.com, you can configure a regex value mapping so that Grafana displays www and truncates the domain.
type RegexMap struct {
	Type string `json:"type"`
	// Regular expression to match against and the result to apply when the value matches the regex
	Options DashboardRegexMapOptions `json:"options"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `RegexMap` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *RegexMap) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "type"
	if fields["type"] != nil {
		if string(fields["type"]) != "null" {
			if err := json.Unmarshal(fields["type"], &resource.Type); err != nil {
				errs = append(errs, cog.MakeBuildErrors("type", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is null"))...)

		}
		delete(fields, "type")
	} else {
		errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is missing from input"))...)
	}
	// Field "options"
	if fields["options"] != nil {
		if string(fields["options"]) != "null" {

			resource.Options = DashboardRegexMapOptions{}
			if err := resource.Options.UnmarshalJSONStrict(fields["options"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("options", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("options", errors.New("required field is null"))...)

		}
		delete(fields, "options")
	} else {
		errs = append(errs, cog.MakeBuildErrors("options", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("RegexMap", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `RegexMap` objects.
func (resource RegexMap) Equals(other RegexMap) bool {
	if resource.Type != other.Type {
		return false
	}
	if !resource.Options.Equals(other.Options) {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `RegexMap` fields for violations and returns them.
func (resource RegexMap) Validate() error {
	var errs cog.BuildErrors
	if !(resource.Type == "regex") {
		errs = append(errs, cog.MakeBuildErrors(
			"type",
			errors.New("must be == regex"),
		)...)
	}
	if err := resource.Options.Validate(); err != nil {
		errs = append(errs, cog.MakeBuildErrors("options", err)...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Maps special values like Null, NaN (not a number), and boolean values like true and false to a display text and color.
// See SpecialValueMatch to see the list of special values.
// For example, you can configure a special value mapping so that null values appear as N/A.
type SpecialValueMap struct {
	Type    string                          `json:"type"`
	Options DashboardSpecialValueMapOptions `json:"options"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `SpecialValueMap` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *SpecialValueMap) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "type"
	if fields["type"] != nil {
		if string(fields["type"]) != "null" {
			if err := json.Unmarshal(fields["type"], &resource.Type); err != nil {
				errs = append(errs, cog.MakeBuildErrors("type", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is null"))...)

		}
		delete(fields, "type")
	} else {
		errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is missing from input"))...)
	}
	// Field "options"
	if fields["options"] != nil {
		if string(fields["options"]) != "null" {

			resource.Options = DashboardSpecialValueMapOptions{}
			if err := resource.Options.UnmarshalJSONStrict(fields["options"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("options", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("options", errors.New("required field is null"))...)

		}
		delete(fields, "options")
	} else {
		errs = append(errs, cog.MakeBuildErrors("options", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("SpecialValueMap", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `SpecialValueMap` objects.
func (resource SpecialValueMap) Equals(other SpecialValueMap) bool {
	if resource.Type != other.Type {
		return false
	}
	if !resource.Options.Equals(other.Options) {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `SpecialValueMap` fields for violations and returns them.
func (resource SpecialValueMap) Validate() error {
	var errs cog.BuildErrors
	if !(resource.Type == "special") {
		errs = append(errs, cog.MakeBuildErrors(
			"type",
			errors.New("must be == special"),
		)...)
	}
	if err := resource.Options.Validate(); err != nil {
		errs = append(errs, cog.MakeBuildErrors("options", err)...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Special value types supported by the `SpecialValueMap`
type SpecialValueMatch string

const (
	SpecialValueMatchTrue       SpecialValueMatch = "true"
	SpecialValueMatchFalse      SpecialValueMatch = "false"
	SpecialValueMatchNull       SpecialValueMatch = "null"
	SpecialValueMatchNaN        SpecialValueMatch = "nan"
	SpecialValueMatchNullAndNan SpecialValueMatch = "null+nan"
	SpecialValueMatchEmpty      SpecialValueMatch = "empty"
)

// Result used as replacement with text and color when the value matches
type ValueMappingResult struct {
	// Text to display when the value matches
	Text *string `json:"text,omitempty"`
	// Text to use when the value matches
	Color *string `json:"color,omitempty"`
	// Icon to display when the value matches. Only specific visualizations.
	Icon *string `json:"icon,omitempty"`
	// Position in the mapping array. Only used internally.
	Index *int32 `json:"index,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `ValueMappingResult` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *ValueMappingResult) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "text"
	if fields["text"] != nil {
		if string(fields["text"]) != "null" {
			if err := json.Unmarshal(fields["text"], &resource.Text); err != nil {
				errs = append(errs, cog.MakeBuildErrors("text", err)...)
			}

		}
		delete(fields, "text")

	}
	// Field "color"
	if fields["color"] != nil {
		if string(fields["color"]) != "null" {
			if err := json.Unmarshal(fields["color"], &resource.Color); err != nil {
				errs = append(errs, cog.MakeBuildErrors("color", err)...)
			}

		}
		delete(fields, "color")

	}
	// Field "icon"
	if fields["icon"] != nil {
		if string(fields["icon"]) != "null" {
			if err := json.Unmarshal(fields["icon"], &resource.Icon); err != nil {
				errs = append(errs, cog.MakeBuildErrors("icon", err)...)
			}

		}
		delete(fields, "icon")

	}
	// Field "index"
	if fields["index"] != nil {
		if string(fields["index"]) != "null" {
			if err := json.Unmarshal(fields["index"], &resource.Index); err != nil {
				errs = append(errs, cog.MakeBuildErrors("index", err)...)
			}

		}
		delete(fields, "index")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("ValueMappingResult", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `ValueMappingResult` objects.
func (resource ValueMappingResult) Equals(other ValueMappingResult) bool {
	if resource.Text == nil && other.Text != nil || resource.Text != nil && other.Text == nil {
		return false
	}

	if resource.Text != nil {
		if *resource.Text != *other.Text {
			return false
		}
	}
	if resource.Color == nil && other.Color != nil || resource.Color != nil && other.Color == nil {
		return false
	}

	if resource.Color != nil {
		if *resource.Color != *other.Color {
			return false
		}
	}
	if resource.Icon == nil && other.Icon != nil || resource.Icon != nil && other.Icon == nil {
		return false
	}

	if resource.Icon != nil {
		if *resource.Icon != *other.Icon {
			return false
		}
	}
	if resource.Index == nil && other.Index != nil || resource.Index != nil && other.Index == nil {
		return false
	}

	if resource.Index != nil {
		if *resource.Index != *other.Index {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `ValueMappingResult` fields for violations and returns them.
func (resource ValueMappingResult) Validate() error {
	return nil
}

// Transformations allow to manipulate data returned by a query before the system applies a visualization.
// Using transformations you can: rename fields, join time series data, perform mathematical operations across queries,
// use the output of one transformation as the input to another transformation, etc.
type DataTransformerConfig struct {
	// Unique identifier of transformer
	Id string `json:"id"`
	// Disabled transformations are skipped
	Disabled *bool `json:"disabled,omitempty"`
	// Optional frame matcher. When missing it will be applied to all results
	Filter *MatcherConfig `json:"filter,omitempty"`
	// Options to be passed to the transformer
	// Valid options depend on the transformer id
	Options any `json:"options"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `DataTransformerConfig` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *DataTransformerConfig) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "id"
	if fields["id"] != nil {
		if string(fields["id"]) != "null" {
			if err := json.Unmarshal(fields["id"], &resource.Id); err != nil {
				errs = append(errs, cog.MakeBuildErrors("id", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("id", errors.New("required field is null"))...)

		}
		delete(fields, "id")
	} else {
		errs = append(errs, cog.MakeBuildErrors("id", errors.New("required field is missing from input"))...)
	}
	// Field "disabled"
	if fields["disabled"] != nil {
		if string(fields["disabled"]) != "null" {
			if err := json.Unmarshal(fields["disabled"], &resource.Disabled); err != nil {
				errs = append(errs, cog.MakeBuildErrors("disabled", err)...)
			}

		}
		delete(fields, "disabled")

	}
	// Field "filter"
	if fields["filter"] != nil {
		if string(fields["filter"]) != "null" {

			resource.Filter = &MatcherConfig{}
			if err := resource.Filter.UnmarshalJSONStrict(fields["filter"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("filter", err)...)
			}

		}
		delete(fields, "filter")

	}
	// Field "options"
	if fields["options"] != nil {
		if string(fields["options"]) != "null" {
			if err := json.Unmarshal(fields["options"], &resource.Options); err != nil {
				errs = append(errs, cog.MakeBuildErrors("options", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("options", errors.New("required field is null"))...)

		}
		delete(fields, "options")
	} else {
		errs = append(errs, cog.MakeBuildErrors("options", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("DataTransformerConfig", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `DataTransformerConfig` objects.
func (resource DataTransformerConfig) Equals(other DataTransformerConfig) bool {
	if resource.Id != other.Id {
		return false
	}
	if resource.Disabled == nil && other.Disabled != nil || resource.Disabled != nil && other.Disabled == nil {
		return false
	}

	if resource.Disabled != nil {
		if *resource.Disabled != *other.Disabled {
			return false
		}
	}
	if resource.Filter == nil && other.Filter != nil || resource.Filter != nil && other.Filter == nil {
		return false
	}

	if resource.Filter != nil {
		if !resource.Filter.Equals(*other.Filter) {
			return false
		}
	}
	// is DeepEqual good enough here?
	if !reflect.DeepEqual(resource.Options, other.Options) {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `DataTransformerConfig` fields for violations and returns them.
func (resource DataTransformerConfig) Validate() error {
	var errs cog.BuildErrors
	if resource.Filter != nil {
		if err := resource.Filter.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("filter", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// 0 for no shared crosshair or tooltip (default).
// 1 for shared crosshair.
// 2 for shared crosshair AND shared tooltip.
type DashboardCursorSync int64

const (
	DashboardCursorSyncOff       DashboardCursorSync = 0
	DashboardCursorSyncCrosshair DashboardCursorSync = 1
	DashboardCursorSyncTooltip   DashboardCursorSync = 2
)

// A dashboard snapshot shares an interactive dashboard publicly.
// It is a read-only version of a dashboard, and is not editable.
// It is possible to create a snapshot of a snapshot.
// Grafana strips away all sensitive information from the dashboard.
// Sensitive information stripped: queries (metric, template,annotation) and panel links.
type Snapshot struct {
	// Time when the snapshot was created
	Created time.Time `json:"created"`
	// Time when the snapshot expires, default is never to expire
	Expires string `json:"expires"`
	// Is the snapshot saved in an external grafana instance
	External bool `json:"external"`
	// external url, if snapshot was shared in external grafana instance
	ExternalUrl string `json:"externalUrl"`
	// Unique identifier of the snapshot
	Id uint32 `json:"id"`
	// Optional, defined the unique key of the snapshot, required if external is true
	Key string `json:"key"`
	// Optional, name of the snapshot
	Name string `json:"name"`
	// org id of the snapshot
	OrgId uint32 `json:"orgId"`
	// last time when the snapshot was updated
	Updated time.Time `json:"updated"`
	// url of the snapshot, if snapshot was shared internally
	Url *string `json:"url,omitempty"`
	// user id of the snapshot creator
	UserId    uint32     `json:"userId"`
	Dashboard *Dashboard `json:"dashboard,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `Snapshot` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *Snapshot) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "created"
	if fields["created"] != nil {
		if string(fields["created"]) != "null" {
			if err := json.Unmarshal(fields["created"], &resource.Created); err != nil {
				errs = append(errs, cog.MakeBuildErrors("created", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("created", errors.New("required field is null"))...)

		}
		delete(fields, "created")
	} else {
		errs = append(errs, cog.MakeBuildErrors("created", errors.New("required field is missing from input"))...)
	}
	// Field "expires"
	if fields["expires"] != nil {
		if string(fields["expires"]) != "null" {
			if err := json.Unmarshal(fields["expires"], &resource.Expires); err != nil {
				errs = append(errs, cog.MakeBuildErrors("expires", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("expires", errors.New("required field is null"))...)

		}
		delete(fields, "expires")
	} else {
		errs = append(errs, cog.MakeBuildErrors("expires", errors.New("required field is missing from input"))...)
	}
	// Field "external"
	if fields["external"] != nil {
		if string(fields["external"]) != "null" {
			if err := json.Unmarshal(fields["external"], &resource.External); err != nil {
				errs = append(errs, cog.MakeBuildErrors("external", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("external", errors.New("required field is null"))...)

		}
		delete(fields, "external")
	} else {
		errs = append(errs, cog.MakeBuildErrors("external", errors.New("required field is missing from input"))...)
	}
	// Field "externalUrl"
	if fields["externalUrl"] != nil {
		if string(fields["externalUrl"]) != "null" {
			if err := json.Unmarshal(fields["externalUrl"], &resource.ExternalUrl); err != nil {
				errs = append(errs, cog.MakeBuildErrors("externalUrl", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("externalUrl", errors.New("required field is null"))...)

		}
		delete(fields, "externalUrl")
	} else {
		errs = append(errs, cog.MakeBuildErrors("externalUrl", errors.New("required field is missing from input"))...)
	}
	// Field "id"
	if fields["id"] != nil {
		if string(fields["id"]) != "null" {
			if err := json.Unmarshal(fields["id"], &resource.Id); err != nil {
				errs = append(errs, cog.MakeBuildErrors("id", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("id", errors.New("required field is null"))...)

		}
		delete(fields, "id")
	} else {
		errs = append(errs, cog.MakeBuildErrors("id", errors.New("required field is missing from input"))...)
	}
	// Field "key"
	if fields["key"] != nil {
		if string(fields["key"]) != "null" {
			if err := json.Unmarshal(fields["key"], &resource.Key); err != nil {
				errs = append(errs, cog.MakeBuildErrors("key", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("key", errors.New("required field is null"))...)

		}
		delete(fields, "key")
	} else {
		errs = append(errs, cog.MakeBuildErrors("key", errors.New("required field is missing from input"))...)
	}
	// Field "name"
	if fields["name"] != nil {
		if string(fields["name"]) != "null" {
			if err := json.Unmarshal(fields["name"], &resource.Name); err != nil {
				errs = append(errs, cog.MakeBuildErrors("name", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("name", errors.New("required field is null"))...)

		}
		delete(fields, "name")
	} else {
		errs = append(errs, cog.MakeBuildErrors("name", errors.New("required field is missing from input"))...)
	}
	// Field "orgId"
	if fields["orgId"] != nil {
		if string(fields["orgId"]) != "null" {
			if err := json.Unmarshal(fields["orgId"], &resource.OrgId); err != nil {
				errs = append(errs, cog.MakeBuildErrors("orgId", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("orgId", errors.New("required field is null"))...)

		}
		delete(fields, "orgId")
	} else {
		errs = append(errs, cog.MakeBuildErrors("orgId", errors.New("required field is missing from input"))...)
	}
	// Field "updated"
	if fields["updated"] != nil {
		if string(fields["updated"]) != "null" {
			if err := json.Unmarshal(fields["updated"], &resource.Updated); err != nil {
				errs = append(errs, cog.MakeBuildErrors("updated", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("updated", errors.New("required field is null"))...)

		}
		delete(fields, "updated")
	} else {
		errs = append(errs, cog.MakeBuildErrors("updated", errors.New("required field is missing from input"))...)
	}
	// Field "url"
	if fields["url"] != nil {
		if string(fields["url"]) != "null" {
			if err := json.Unmarshal(fields["url"], &resource.Url); err != nil {
				errs = append(errs, cog.MakeBuildErrors("url", err)...)
			}

		}
		delete(fields, "url")

	}
	// Field "userId"
	if fields["userId"] != nil {
		if string(fields["userId"]) != "null" {
			if err := json.Unmarshal(fields["userId"], &resource.UserId); err != nil {
				errs = append(errs, cog.MakeBuildErrors("userId", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("userId", errors.New("required field is null"))...)

		}
		delete(fields, "userId")
	} else {
		errs = append(errs, cog.MakeBuildErrors("userId", errors.New("required field is missing from input"))...)
	}
	// Field "dashboard"
	if fields["dashboard"] != nil {
		if string(fields["dashboard"]) != "null" {

			resource.Dashboard = &Dashboard{}
			if err := resource.Dashboard.UnmarshalJSONStrict(fields["dashboard"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("dashboard", err)...)
			}

		}
		delete(fields, "dashboard")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("Snapshot", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `Snapshot` objects.
func (resource Snapshot) Equals(other Snapshot) bool {
	if resource.Created != other.Created {
		return false
	}
	if resource.Expires != other.Expires {
		return false
	}
	if resource.External != other.External {
		return false
	}
	if resource.ExternalUrl != other.ExternalUrl {
		return false
	}
	if resource.Id != other.Id {
		return false
	}
	if resource.Key != other.Key {
		return false
	}
	if resource.Name != other.Name {
		return false
	}
	if resource.OrgId != other.OrgId {
		return false
	}
	if resource.Updated != other.Updated {
		return false
	}
	if resource.Url == nil && other.Url != nil || resource.Url != nil && other.Url == nil {
		return false
	}

	if resource.Url != nil {
		if *resource.Url != *other.Url {
			return false
		}
	}
	if resource.UserId != other.UserId {
		return false
	}
	if resource.Dashboard == nil && other.Dashboard != nil || resource.Dashboard != nil && other.Dashboard == nil {
		return false
	}

	if resource.Dashboard != nil {
		if !resource.Dashboard.Equals(*other.Dashboard) {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `Snapshot` fields for violations and returns them.
func (resource Snapshot) Validate() error {
	var errs cog.BuildErrors
	if resource.Dashboard != nil {
		if err := resource.Dashboard.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("dashboard", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Dashboard panels are the basic visualization building blocks.
type Panel struct {
	// The panel plugin type id. This is used to find the plugin to display the panel.
	Type string `json:"type"`
	// Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
	Id *uint32 `json:"id,omitempty"`
	// The version of the plugin that is used for this panel. This is used to find the plugin to display the panel and to migrate old panel configs.
	PluginVersion *string `json:"pluginVersion,omitempty"`
	// Tags for the panel.
	Tags []string `json:"tags,omitempty"`
	// Depends on the panel plugin. See the plugin documentation for details.
	Targets []variants.Dataquery `json:"targets,omitempty"`
	// Panel title.
	Title *string `json:"title,omitempty"`
	// Panel description.
	Description *string `json:"description,omitempty"`
	// Whether to display the panel without a background.
	Transparent bool `json:"transparent"`
	// The datasource used in all targets.
	Datasource *DataSourceRef `json:"datasource,omitempty"`
	// Grid position.
	GridPos *GridPos `json:"gridPos,omitempty"`
	// Panel links.
	Links []DashboardLink `json:"links,omitempty"`
	// Name of template variable to repeat for.
	Repeat *string `json:"repeat,omitempty"`
	// Direction to repeat in if 'repeat' is set.
	// `h` for horizontal, `v` for vertical.
	RepeatDirection *PanelRepeatDirection `json:"repeatDirection,omitempty"`
	// Id of the repeating panel.
	RepeatPanelId *int64 `json:"repeatPanelId,omitempty"`
	// The maximum number of data points that the panel queries are retrieving.
	MaxDataPoints *float64 `json:"maxDataPoints,omitempty"`
	// List of transformations that are applied to the panel data before rendering.
	// When there are multiple transformations, Grafana applies them in the order they are listed.
	// Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
	Transformations []DataTransformerConfig `json:"transformations"`
	// The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
	// This value must be formatted as a number followed by a valid time
	// identifier like: "40s", "3d", etc.
	// See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
	Interval *string `json:"interval,omitempty"`
	// Overrides the relative time range for individual panels,
	// which causes them to be different than what is selected in
	// the dashboard time picker in the top-right corner of the dashboard. You can use this to show metrics from different
	// time periods or days on the same dashboard.
	// The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
	// `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
	// Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
	// See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
	TimeFrom *string `json:"timeFrom,omitempty"`
	// Overrides the time range for individual panels by shifting its start and end relative to the time picker.
	// For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
	// Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
	// See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
	TimeShift *string `json:"timeShift,omitempty"`
	// Dynamically load the panel
	LibraryPanel *LibraryPanelRef `json:"libraryPanel,omitempty"`
	// It depends on the panel plugin. They are specified by the Options field in panel plugin schemas.
	Options any `json:"options"`
	// Field options allow you to change how the data is displayed in your visualizations.
	FieldConfig FieldConfigSource `json:"fieldConfig"`
}

func (resource *Panel) UnmarshalJSON(raw []byte) error {
	if raw == nil {
		return nil
	}

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	if fields["type"] != nil {
		if err := json.Unmarshal(fields["type"], &resource.Type); err != nil {
			return fmt.Errorf("error decoding field 'type': %w", err)
		}
	}
	if fields["id"] != nil {
		if err := json.Unmarshal(fields["id"], &resource.Id); err != nil {
			return fmt.Errorf("error decoding field 'id': %w", err)
		}
	}
	if fields["pluginVersion"] != nil {
		if err := json.Unmarshal(fields["pluginVersion"], &resource.PluginVersion); err != nil {
			return fmt.Errorf("error decoding field 'pluginVersion': %w", err)
		}
	}
	if fields["tags"] != nil {
		if err := json.Unmarshal(fields["tags"], &resource.Tags); err != nil {
			return fmt.Errorf("error decoding field 'tags': %w", err)
		}
	}

	if fields["title"] != nil {
		if err := json.Unmarshal(fields["title"], &resource.Title); err != nil {
			return fmt.Errorf("error decoding field 'title': %w", err)
		}
	}
	if fields["description"] != nil {
		if err := json.Unmarshal(fields["description"], &resource.Description); err != nil {
			return fmt.Errorf("error decoding field 'description': %w", err)
		}
	}
	if fields["transparent"] != nil {
		if err := json.Unmarshal(fields["transparent"], &resource.Transparent); err != nil {
			return fmt.Errorf("error decoding field 'transparent': %w", err)
		}
	}
	if fields["datasource"] != nil {
		if err := json.Unmarshal(fields["datasource"], &resource.Datasource); err != nil {
			return fmt.Errorf("error decoding field 'datasource': %w", err)
		}
	}
	if fields["gridPos"] != nil {
		if err := json.Unmarshal(fields["gridPos"], &resource.GridPos); err != nil {
			return fmt.Errorf("error decoding field 'gridPos': %w", err)
		}
	}
	if fields["links"] != nil {
		if err := json.Unmarshal(fields["links"], &resource.Links); err != nil {
			return fmt.Errorf("error decoding field 'links': %w", err)
		}
	}
	if fields["repeat"] != nil {
		if err := json.Unmarshal(fields["repeat"], &resource.Repeat); err != nil {
			return fmt.Errorf("error decoding field 'repeat': %w", err)
		}
	}
	if fields["repeatDirection"] != nil {
		if err := json.Unmarshal(fields["repeatDirection"], &resource.RepeatDirection); err != nil {
			return fmt.Errorf("error decoding field 'repeatDirection': %w", err)
		}
	}
	if fields["repeatPanelId"] != nil {
		if err := json.Unmarshal(fields["repeatPanelId"], &resource.RepeatPanelId); err != nil {
			return fmt.Errorf("error decoding field 'repeatPanelId': %w", err)
		}
	}
	if fields["maxDataPoints"] != nil {
		if err := json.Unmarshal(fields["maxDataPoints"], &resource.MaxDataPoints); err != nil {
			return fmt.Errorf("error decoding field 'maxDataPoints': %w", err)
		}
	}
	if fields["transformations"] != nil {
		if err := json.Unmarshal(fields["transformations"], &resource.Transformations); err != nil {
			return fmt.Errorf("error decoding field 'transformations': %w", err)
		}
	}
	if fields["interval"] != nil {
		if err := json.Unmarshal(fields["interval"], &resource.Interval); err != nil {
			return fmt.Errorf("error decoding field 'interval': %w", err)
		}
	}
	if fields["timeFrom"] != nil {
		if err := json.Unmarshal(fields["timeFrom"], &resource.TimeFrom); err != nil {
			return fmt.Errorf("error decoding field 'timeFrom': %w", err)
		}
	}
	if fields["timeShift"] != nil {
		if err := json.Unmarshal(fields["timeShift"], &resource.TimeShift); err != nil {
			return fmt.Errorf("error decoding field 'timeShift': %w", err)
		}
	}
	if fields["libraryPanel"] != nil {
		if err := json.Unmarshal(fields["libraryPanel"], &resource.LibraryPanel); err != nil {
			return fmt.Errorf("error decoding field 'libraryPanel': %w", err)
		}
	}
	if fields["options"] != nil {
		variantCfg, found := cog.ConfigForPanelcfgVariant(resource.Type)
		if found && variantCfg.OptionsUnmarshaler != nil {
			options, err := variantCfg.OptionsUnmarshaler(fields["options"])
			if err != nil {
				return err
			}
			resource.Options = options
		} else {
			if err := json.Unmarshal(fields["options"], &resource.Options); err != nil {
				return err
			}
		}
	}
	if fields["fieldConfig"] != nil {
		if err := json.Unmarshal(fields["fieldConfig"], &resource.FieldConfig); err != nil {
			return err
		}

		variantCfg, found := cog.ConfigForPanelcfgVariant(resource.Type)
		if found && variantCfg.FieldConfigUnmarshaler != nil {
			fakeFieldConfigSource := struct {
				Defaults struct {
					Custom json.RawMessage `json:"custom"`
				} `json:"defaults"`
			}{}
			if err := json.Unmarshal(fields["fieldConfig"], &fakeFieldConfigSource); err != nil {
				return err
			}

			if fakeFieldConfigSource.Defaults.Custom != nil {
				customFieldConfig, err := variantCfg.FieldConfigUnmarshaler(fakeFieldConfigSource.Defaults.Custom)
				if err != nil {
					return err
				}

				resource.FieldConfig.Defaults.Custom = customFieldConfig
			}
		}
	}

	if fields["targets"] != nil {
		dataqueryTypeHint := ""
		if resource.Datasource != nil && resource.Datasource.Type != nil {
			dataqueryTypeHint = *resource.Datasource.Type
		}

		targets, err := cog.UnmarshalDataqueryArray(fields["targets"], dataqueryTypeHint)
		if err != nil {
			return err
		}
		resource.Targets = targets
	}

	return nil
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `Panel` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *Panel) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "type"
	if fields["type"] != nil {
		if string(fields["type"]) != "null" {
			if err := json.Unmarshal(fields["type"], &resource.Type); err != nil {
				errs = append(errs, cog.MakeBuildErrors("type", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is null"))...)

		}
		delete(fields, "type")
	} else {
		errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is missing from input"))...)
	}
	// Field "id"
	if fields["id"] != nil {
		if string(fields["id"]) != "null" {
			if err := json.Unmarshal(fields["id"], &resource.Id); err != nil {
				errs = append(errs, cog.MakeBuildErrors("id", err)...)
			}

		}
		delete(fields, "id")

	}
	// Field "pluginVersion"
	if fields["pluginVersion"] != nil {
		if string(fields["pluginVersion"]) != "null" {
			if err := json.Unmarshal(fields["pluginVersion"], &resource.PluginVersion); err != nil {
				errs = append(errs, cog.MakeBuildErrors("pluginVersion", err)...)
			}

		}
		delete(fields, "pluginVersion")

	}
	// Field "tags"
	if fields["tags"] != nil {
		if string(fields["tags"]) != "null" {

			if err := json.Unmarshal(fields["tags"], &resource.Tags); err != nil {
				errs = append(errs, cog.MakeBuildErrors("tags", err)...)
			}

		}
		delete(fields, "tags")

	}
	// Field "targets"
	if fields["targets"] != nil {
		if string(fields["targets"]) != "null" {

			rawDataqueries := []json.RawMessage{}
			if err := json.Unmarshal(fields["targets"], &rawDataqueries); err != nil {
				return err
			}

			dataqueryTypeHint := ""
			if resource.Datasource != nil && resource.Datasource.Type != nil {
				dataqueryTypeHint = *resource.Datasource.Type
			}

			for i1 := range rawDataqueries {
				dataquery, err := cog.StrictUnmarshalDataquery(rawDataqueries[i1], dataqueryTypeHint)
				if err != nil {
					errs = append(errs, cog.MakeBuildErrors("targets["+strconv.Itoa(i1)+"]", err)...)
					continue
				}

				resource.Targets = append(resource.Targets, dataquery)
			}

		}
		delete(fields, "targets")

	}
	// Field "title"
	if fields["title"] != nil {
		if string(fields["title"]) != "null" {
			if err := json.Unmarshal(fields["title"], &resource.Title); err != nil {
				errs = append(errs, cog.MakeBuildErrors("title", err)...)
			}

		}
		delete(fields, "title")

	}
	// Field "description"
	if fields["description"] != nil {
		if string(fields["description"]) != "null" {
			if err := json.Unmarshal(fields["description"], &resource.Description); err != nil {
				errs = append(errs, cog.MakeBuildErrors("description", err)...)
			}

		}
		delete(fields, "description")

	}
	// Field "transparent"
	if fields["transparent"] != nil {
		if string(fields["transparent"]) != "null" {
			if err := json.Unmarshal(fields["transparent"], &resource.Transparent); err != nil {
				errs = append(errs, cog.MakeBuildErrors("transparent", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("transparent", errors.New("required field is null"))...)

		}
		delete(fields, "transparent")
	} else {
		errs = append(errs, cog.MakeBuildErrors("transparent", errors.New("required field is missing from input"))...)
	}
	// Field "datasource"
	if fields["datasource"] != nil {
		if string(fields["datasource"]) != "null" {

			resource.Datasource = &DataSourceRef{}
			if err := resource.Datasource.UnmarshalJSONStrict(fields["datasource"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("datasource", err)...)
			}

		}
		delete(fields, "datasource")

	}
	// Field "gridPos"
	if fields["gridPos"] != nil {
		if string(fields["gridPos"]) != "null" {

			resource.GridPos = &GridPos{}
			if err := resource.GridPos.UnmarshalJSONStrict(fields["gridPos"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("gridPos", err)...)
			}

		}
		delete(fields, "gridPos")

	}
	// Field "links"
	if fields["links"] != nil {
		if string(fields["links"]) != "null" {

			partialArray := []json.RawMessage{}
			if err := json.Unmarshal(fields["links"], &partialArray); err != nil {
				return err
			}

			for i1 := range partialArray {
				var result1 DashboardLink

				result1 = DashboardLink{}
				if err := result1.UnmarshalJSONStrict(partialArray[i1]); err != nil {
					errs = append(errs, cog.MakeBuildErrors("links["+strconv.Itoa(i1)+"]", err)...)
				}
				resource.Links = append(resource.Links, result1)
			}

		}
		delete(fields, "links")

	}
	// Field "repeat"
	if fields["repeat"] != nil {
		if string(fields["repeat"]) != "null" {
			if err := json.Unmarshal(fields["repeat"], &resource.Repeat); err != nil {
				errs = append(errs, cog.MakeBuildErrors("repeat", err)...)
			}

		}
		delete(fields, "repeat")

	}
	// Field "repeatDirection"
	if fields["repeatDirection"] != nil {
		if string(fields["repeatDirection"]) != "null" {
			if err := json.Unmarshal(fields["repeatDirection"], &resource.RepeatDirection); err != nil {
				errs = append(errs, cog.MakeBuildErrors("repeatDirection", err)...)
			}

		}
		delete(fields, "repeatDirection")

	}
	// Field "repeatPanelId"
	if fields["repeatPanelId"] != nil {
		if string(fields["repeatPanelId"]) != "null" {
			if err := json.Unmarshal(fields["repeatPanelId"], &resource.RepeatPanelId); err != nil {
				errs = append(errs, cog.MakeBuildErrors("repeatPanelId", err)...)
			}

		}
		delete(fields, "repeatPanelId")

	}
	// Field "maxDataPoints"
	if fields["maxDataPoints"] != nil {
		if string(fields["maxDataPoints"]) != "null" {
			if err := json.Unmarshal(fields["maxDataPoints"], &resource.MaxDataPoints); err != nil {
				errs = append(errs, cog.MakeBuildErrors("maxDataPoints", err)...)
			}

		}
		delete(fields, "maxDataPoints")

	}
	// Field "transformations"
	if fields["transformations"] != nil {
		if string(fields["transformations"]) != "null" {

			partialArray := []json.RawMessage{}
			if err := json.Unmarshal(fields["transformations"], &partialArray); err != nil {
				return err
			}

			for i1 := range partialArray {
				var result1 DataTransformerConfig

				result1 = DataTransformerConfig{}
				if err := result1.UnmarshalJSONStrict(partialArray[i1]); err != nil {
					errs = append(errs, cog.MakeBuildErrors("transformations["+strconv.Itoa(i1)+"]", err)...)
				}
				resource.Transformations = append(resource.Transformations, result1)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("transformations", errors.New("required field is null"))...)

		}
		delete(fields, "transformations")
	} else {
		errs = append(errs, cog.MakeBuildErrors("transformations", errors.New("required field is missing from input"))...)
	}
	// Field "interval"
	if fields["interval"] != nil {
		if string(fields["interval"]) != "null" {
			if err := json.Unmarshal(fields["interval"], &resource.Interval); err != nil {
				errs = append(errs, cog.MakeBuildErrors("interval", err)...)
			}

		}
		delete(fields, "interval")

	}
	// Field "timeFrom"
	if fields["timeFrom"] != nil {
		if string(fields["timeFrom"]) != "null" {
			if err := json.Unmarshal(fields["timeFrom"], &resource.TimeFrom); err != nil {
				errs = append(errs, cog.MakeBuildErrors("timeFrom", err)...)
			}

		}
		delete(fields, "timeFrom")

	}
	// Field "timeShift"
	if fields["timeShift"] != nil {
		if string(fields["timeShift"]) != "null" {
			if err := json.Unmarshal(fields["timeShift"], &resource.TimeShift); err != nil {
				errs = append(errs, cog.MakeBuildErrors("timeShift", err)...)
			}

		}
		delete(fields, "timeShift")

	}
	// Field "libraryPanel"
	if fields["libraryPanel"] != nil {
		if string(fields["libraryPanel"]) != "null" {

			resource.LibraryPanel = &LibraryPanelRef{}
			if err := resource.LibraryPanel.UnmarshalJSONStrict(fields["libraryPanel"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("libraryPanel", err)...)
			}

		}
		delete(fields, "libraryPanel")

	}
	// Field "options"
	if fields["options"] != nil {
		if string(fields["options"]) != "null" {

			variantCfg, found := cog.ConfigForPanelcfgVariant(resource.Type)
			if found && variantCfg.StrictOptionsUnmarshaler != nil {
				options, err := variantCfg.StrictOptionsUnmarshaler(fields["options"])
				if err != nil {
					errs = append(errs, cog.MakeBuildErrors("options", err)...)
				} else {
					resource.Options = options
				}
			} else {
				if err := json.Unmarshal(fields["options"], &resource.Options); err != nil {
					errs = append(errs, cog.MakeBuildErrors("options", err)...)
				}
			}

		} else {
			errs = append(errs, cog.MakeBuildErrors("options", errors.New("required field is null"))...)

		}
		delete(fields, "options")
	} else {
		errs = append(errs, cog.MakeBuildErrors("options", errors.New("required field is missing from input"))...)
	}
	// Field "fieldConfig"
	if fields["fieldConfig"] != nil {
		if string(fields["fieldConfig"]) != "null" {

			if err := json.Unmarshal(fields["fieldConfig"], &resource.FieldConfig); err != nil {
				errs = append(errs, cog.MakeBuildErrors("fieldConfig", err)...)
			}

			variantCfg, found := cog.ConfigForPanelcfgVariant(resource.Type)
			if found && variantCfg.StrictFieldConfigUnmarshaler != nil {
				fakeFieldConfigSource := struct {
					Defaults struct {
						Custom json.RawMessage `json:"custom"`
					} `json:"defaults"`
				}{}
				if err := json.Unmarshal(fields["fieldConfig"], &fakeFieldConfigSource); err != nil {
					errs = append(errs, cog.MakeBuildErrors("fieldConfig", err)...)
				}

				if fakeFieldConfigSource.Defaults.Custom != nil {
					customFieldConfig, err := variantCfg.StrictFieldConfigUnmarshaler(fakeFieldConfigSource.Defaults.Custom)
					if err != nil {
						errs = append(errs, cog.MakeBuildErrors("fieldConfig.defaults.custom", err)...)
					} else {
						resource.FieldConfig.Defaults.Custom = customFieldConfig
					}
				}
			}

		} else {
			errs = append(errs, cog.MakeBuildErrors("fieldConfig", errors.New("required field is null"))...)

		}
		delete(fields, "fieldConfig")
	} else {
		errs = append(errs, cog.MakeBuildErrors("fieldConfig", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("Panel", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `Panel` objects.
func (resource Panel) Equals(other Panel) bool {
	if resource.Type != other.Type {
		return false
	}
	if resource.Id == nil && other.Id != nil || resource.Id != nil && other.Id == nil {
		return false
	}

	if resource.Id != nil {
		if *resource.Id != *other.Id {
			return false
		}
	}
	if resource.PluginVersion == nil && other.PluginVersion != nil || resource.PluginVersion != nil && other.PluginVersion == nil {
		return false
	}

	if resource.PluginVersion != nil {
		if *resource.PluginVersion != *other.PluginVersion {
			return false
		}
	}

	if len(resource.Tags) != len(other.Tags) {
		return false
	}

	for i1 := range resource.Tags {
		if resource.Tags[i1] != other.Tags[i1] {
			return false
		}
	}

	if len(resource.Targets) != len(other.Targets) {
		return false
	}

	for i1 := range resource.Targets {
		if !resource.Targets[i1].Equals(other.Targets[i1]) {
			return false
		}
	}
	if resource.Title == nil && other.Title != nil || resource.Title != nil && other.Title == nil {
		return false
	}

	if resource.Title != nil {
		if *resource.Title != *other.Title {
			return false
		}
	}
	if resource.Description == nil && other.Description != nil || resource.Description != nil && other.Description == nil {
		return false
	}

	if resource.Description != nil {
		if *resource.Description != *other.Description {
			return false
		}
	}
	if resource.Transparent != other.Transparent {
		return false
	}
	if resource.Datasource == nil && other.Datasource != nil || resource.Datasource != nil && other.Datasource == nil {
		return false
	}

	if resource.Datasource != nil {
		if !resource.Datasource.Equals(*other.Datasource) {
			return false
		}
	}
	if resource.GridPos == nil && other.GridPos != nil || resource.GridPos != nil && other.GridPos == nil {
		return false
	}

	if resource.GridPos != nil {
		if !resource.GridPos.Equals(*other.GridPos) {
			return false
		}
	}

	if len(resource.Links) != len(other.Links) {
		return false
	}

	for i1 := range resource.Links {
		if !resource.Links[i1].Equals(other.Links[i1]) {
			return false
		}
	}
	if resource.Repeat == nil && other.Repeat != nil || resource.Repeat != nil && other.Repeat == nil {
		return false
	}

	if resource.Repeat != nil {
		if *resource.Repeat != *other.Repeat {
			return false
		}
	}
	if resource.RepeatDirection == nil && other.RepeatDirection != nil || resource.RepeatDirection != nil && other.RepeatDirection == nil {
		return false
	}

	if resource.RepeatDirection != nil {
		if *resource.RepeatDirection != *other.RepeatDirection {
			return false
		}
	}
	if resource.RepeatPanelId == nil && other.RepeatPanelId != nil || resource.RepeatPanelId != nil && other.RepeatPanelId == nil {
		return false
	}

	if resource.RepeatPanelId != nil {
		if *resource.RepeatPanelId != *other.RepeatPanelId {
			return false
		}
	}
	if resource.MaxDataPoints == nil && other.MaxDataPoints != nil || resource.MaxDataPoints != nil && other.MaxDataPoints == nil {
		return false
	}

	if resource.MaxDataPoints != nil {
		if *resource.MaxDataPoints != *other.MaxDataPoints {
			return false
		}
	}

	if len(resource.Transformations) != len(other.Transformations) {
		return false
	}

	for i1 := range resource.Transformations {
		if !resource.Transformations[i1].Equals(other.Transformations[i1]) {
			return false
		}
	}
	if resource.Interval == nil && other.Interval != nil || resource.Interval != nil && other.Interval == nil {
		return false
	}

	if resource.Interval != nil {
		if *resource.Interval != *other.Interval {
			return false
		}
	}
	if resource.TimeFrom == nil && other.TimeFrom != nil || resource.TimeFrom != nil && other.TimeFrom == nil {
		return false
	}

	if resource.TimeFrom != nil {
		if *resource.TimeFrom != *other.TimeFrom {
			return false
		}
	}
	if resource.TimeShift == nil && other.TimeShift != nil || resource.TimeShift != nil && other.TimeShift == nil {
		return false
	}

	if resource.TimeShift != nil {
		if *resource.TimeShift != *other.TimeShift {
			return false
		}
	}
	if resource.LibraryPanel == nil && other.LibraryPanel != nil || resource.LibraryPanel != nil && other.LibraryPanel == nil {
		return false
	}

	if resource.LibraryPanel != nil {
		if !resource.LibraryPanel.Equals(*other.LibraryPanel) {
			return false
		}
	}
	// is DeepEqual good enough here?
	if !reflect.DeepEqual(resource.Options, other.Options) {
		return false
	}
	if !resource.FieldConfig.Equals(other.FieldConfig) {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `Panel` fields for violations and returns them.
func (resource Panel) Validate() error {
	var errs cog.BuildErrors
	if !(len([]rune(resource.Type)) >= 1) {
		errs = append(errs, cog.MakeBuildErrors(
			"type",
			errors.New("must be >= 1"),
		)...)
	}

	for i1 := range resource.Targets {
		if err := resource.Targets[i1].Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("targets["+strconv.Itoa(i1)+"]", err)...)
		}
	}
	if resource.Datasource != nil {
		if err := resource.Datasource.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("datasource", err)...)
		}
	}
	if resource.GridPos != nil {
		if err := resource.GridPos.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("gridPos", err)...)
		}
	}

	for i1 := range resource.Links {
		if err := resource.Links[i1].Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("links["+strconv.Itoa(i1)+"]", err)...)
		}
	}

	for i1 := range resource.Transformations {
		if err := resource.Transformations[i1].Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("transformations["+strconv.Itoa(i1)+"]", err)...)
		}
	}
	if resource.LibraryPanel != nil {
		if err := resource.LibraryPanel.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("libraryPanel", err)...)
		}
	}
	if err := resource.FieldConfig.Validate(); err != nil {
		errs = append(errs, cog.MakeBuildErrors("fieldConfig", err)...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// The data model used in Grafana, namely the data frame, is a columnar-oriented table structure that unifies both time series and table query results.
// Each column within this structure is called a field. A field can represent a single time series or table column.
// Field options allow you to change how the data is displayed in your visualizations.
type FieldConfigSource struct {
	// Defaults are the options applied to all fields.
	Defaults FieldConfig `json:"defaults"`
	// Overrides are the options applied to specific fields overriding the defaults.
	Overrides []DashboardFieldConfigSourceOverrides `json:"overrides"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `FieldConfigSource` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *FieldConfigSource) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "defaults"
	if fields["defaults"] != nil {
		if string(fields["defaults"]) != "null" {

			resource.Defaults = FieldConfig{}
			if err := resource.Defaults.UnmarshalJSONStrict(fields["defaults"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("defaults", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("defaults", errors.New("required field is null"))...)

		}
		delete(fields, "defaults")
	} else {
		errs = append(errs, cog.MakeBuildErrors("defaults", errors.New("required field is missing from input"))...)
	}
	// Field "overrides"
	if fields["overrides"] != nil {
		if string(fields["overrides"]) != "null" {

			partialArray := []json.RawMessage{}
			if err := json.Unmarshal(fields["overrides"], &partialArray); err != nil {
				return err
			}

			for i1 := range partialArray {
				var result1 DashboardFieldConfigSourceOverrides

				result1 = DashboardFieldConfigSourceOverrides{}
				if err := result1.UnmarshalJSONStrict(partialArray[i1]); err != nil {
					errs = append(errs, cog.MakeBuildErrors("overrides["+strconv.Itoa(i1)+"]", err)...)
				}
				resource.Overrides = append(resource.Overrides, result1)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("overrides", errors.New("required field is null"))...)

		}
		delete(fields, "overrides")
	} else {
		errs = append(errs, cog.MakeBuildErrors("overrides", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("FieldConfigSource", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `FieldConfigSource` objects.
func (resource FieldConfigSource) Equals(other FieldConfigSource) bool {
	if !resource.Defaults.Equals(other.Defaults) {
		return false
	}

	if len(resource.Overrides) != len(other.Overrides) {
		return false
	}

	for i1 := range resource.Overrides {
		if !resource.Overrides[i1].Equals(other.Overrides[i1]) {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `FieldConfigSource` fields for violations and returns them.
func (resource FieldConfigSource) Validate() error {
	var errs cog.BuildErrors
	if err := resource.Defaults.Validate(); err != nil {
		errs = append(errs, cog.MakeBuildErrors("defaults", err)...)
	}

	for i1 := range resource.Overrides {
		if err := resource.Overrides[i1].Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("overrides["+strconv.Itoa(i1)+"]", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// A library panel is a reusable panel that you can use in any dashboard.
// When you make a change to a library panel, that change propagates to all instances of where the panel is used.
// Library panels streamline reuse of panels across multiple dashboards.
type LibraryPanelRef struct {
	// Library panel name
	Name string `json:"name"`
	// Library panel uid
	Uid string `json:"uid"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `LibraryPanelRef` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *LibraryPanelRef) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "name"
	if fields["name"] != nil {
		if string(fields["name"]) != "null" {
			if err := json.Unmarshal(fields["name"], &resource.Name); err != nil {
				errs = append(errs, cog.MakeBuildErrors("name", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("name", errors.New("required field is null"))...)

		}
		delete(fields, "name")
	} else {
		errs = append(errs, cog.MakeBuildErrors("name", errors.New("required field is missing from input"))...)
	}
	// Field "uid"
	if fields["uid"] != nil {
		if string(fields["uid"]) != "null" {
			if err := json.Unmarshal(fields["uid"], &resource.Uid); err != nil {
				errs = append(errs, cog.MakeBuildErrors("uid", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("uid", errors.New("required field is null"))...)

		}
		delete(fields, "uid")
	} else {
		errs = append(errs, cog.MakeBuildErrors("uid", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("LibraryPanelRef", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `LibraryPanelRef` objects.
func (resource LibraryPanelRef) Equals(other LibraryPanelRef) bool {
	if resource.Name != other.Name {
		return false
	}
	if resource.Uid != other.Uid {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `LibraryPanelRef` fields for violations and returns them.
func (resource LibraryPanelRef) Validate() error {
	return nil
}

// Matcher is a predicate configuration. Based on the config a set of field(s) or values is filtered in order to apply override / transformation.
// It comes with in id ( to resolve implementation from registry) and a configuration that’s specific to a particular matcher type.
type MatcherConfig struct {
	// The matcher id. This is used to find the matcher implementation from registry.
	Id string `json:"id"`
	// The matcher options. This is specific to the matcher implementation.
	Options any `json:"options,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `MatcherConfig` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *MatcherConfig) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "id"
	if fields["id"] != nil {
		if string(fields["id"]) != "null" {
			if err := json.Unmarshal(fields["id"], &resource.Id); err != nil {
				errs = append(errs, cog.MakeBuildErrors("id", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("id", errors.New("required field is null"))...)

		}
		delete(fields, "id")
	} else {
		errs = append(errs, cog.MakeBuildErrors("id", errors.New("required field is missing from input"))...)
	}
	// Field "options"
	if fields["options"] != nil {
		if string(fields["options"]) != "null" {
			if err := json.Unmarshal(fields["options"], &resource.Options); err != nil {
				errs = append(errs, cog.MakeBuildErrors("options", err)...)
			}

		}
		delete(fields, "options")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("MatcherConfig", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `MatcherConfig` objects.
func (resource MatcherConfig) Equals(other MatcherConfig) bool {
	if resource.Id != other.Id {
		return false
	}
	// is DeepEqual good enough here?
	if !reflect.DeepEqual(resource.Options, other.Options) {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `MatcherConfig` fields for violations and returns them.
func (resource MatcherConfig) Validate() error {
	return nil
}

type DynamicConfigValue struct {
	Id    string `json:"id"`
	Value any    `json:"value,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `DynamicConfigValue` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *DynamicConfigValue) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "id"
	if fields["id"] != nil {
		if string(fields["id"]) != "null" {
			if err := json.Unmarshal(fields["id"], &resource.Id); err != nil {
				errs = append(errs, cog.MakeBuildErrors("id", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("id", errors.New("required field is null"))...)

		}
		delete(fields, "id")
	} else {
		errs = append(errs, cog.MakeBuildErrors("id", errors.New("required field is missing from input"))...)
	}
	// Field "value"
	if fields["value"] != nil {
		if string(fields["value"]) != "null" {
			if err := json.Unmarshal(fields["value"], &resource.Value); err != nil {
				errs = append(errs, cog.MakeBuildErrors("value", err)...)
			}

		}
		delete(fields, "value")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("DynamicConfigValue", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `DynamicConfigValue` objects.
func (resource DynamicConfigValue) Equals(other DynamicConfigValue) bool {
	if resource.Id != other.Id {
		return false
	}
	// is DeepEqual good enough here?
	if !reflect.DeepEqual(resource.Value, other.Value) {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `DynamicConfigValue` fields for violations and returns them.
func (resource DynamicConfigValue) Validate() error {
	return nil
}

// The data model used in Grafana, namely the data frame, is a columnar-oriented table structure that unifies both time series and table query results.
// Each column within this structure is called a field. A field can represent a single time series or table column.
// Field options allow you to change how the data is displayed in your visualizations.
type FieldConfig struct {
	// The display value for this field.  This supports template variables blank is auto
	DisplayName *string `json:"displayName,omitempty"`
	// This can be used by data sources that return and explicit naming structure for values and labels
	// When this property is configured, this value is used rather than the default naming strategy.
	DisplayNameFromDS *string `json:"displayNameFromDS,omitempty"`
	// Human readable field metadata
	Description *string `json:"description,omitempty"`
	// An explicit path to the field in the datasource.  When the frame meta includes a path,
	// This will default to `${frame.meta.path}/${field.name}
	//
	// When defined, this value can be used as an identifier within the datasource scope, and
	// may be used to update the results
	Path *string `json:"path,omitempty"`
	// True if data source can write a value to the path. Auth/authz are supported separately
	Writeable *bool `json:"writeable,omitempty"`
	// True if data source field supports ad-hoc filters
	Filterable *bool `json:"filterable,omitempty"`
	// Unit a field should use. The unit you select is applied to all fields except time.
	// You can use the units ID availables in Grafana or a custom unit.
	// Available units in Grafana: https://github.com/grafana/grafana/blob/main/packages/grafana-data/src/valueFormats/categories.ts
	// As custom unit, you can use the following formats:
	// `suffix:<suffix>` for custom unit that should go after value.
	// `prefix:<prefix>` for custom unit that should go before value.
	// `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
	// `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
	// `count:<unit>` for a custom count unit.
	// `currency:<unit>` for custom a currency unit.
	Unit *string `json:"unit,omitempty"`
	// Specify the number of decimals Grafana includes in the rendered value.
	// If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
	// For example 1.1234 will display as 1.12 and 100.456 will display as 100.
	// To display all decimals, set the unit to `String`.
	Decimals *float64 `json:"decimals,omitempty"`
	// The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
	Min *float64 `json:"min,omitempty"`
	// The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
	Max *float64 `json:"max,omitempty"`
	// Convert input values into a display string
	Mappings []ValueMapping `json:"mappings,omitempty"`
	// Map numeric values to states
	Thresholds *ThresholdsConfig `json:"thresholds,omitempty"`
	// Panel color configuration
	Color *FieldColor `json:"color,omitempty"`
	// The behavior when clicking on a result
	Links []any `json:"links,omitempty"`
	// Alternative to empty string
	NoValue *string `json:"noValue,omitempty"`
	// custom is specified by the FieldConfig field
	// in panel plugin schemas.
	Custom any `json:"custom,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `FieldConfig` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *FieldConfig) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "displayName"
	if fields["displayName"] != nil {
		if string(fields["displayName"]) != "null" {
			if err := json.Unmarshal(fields["displayName"], &resource.DisplayName); err != nil {
				errs = append(errs, cog.MakeBuildErrors("displayName", err)...)
			}

		}
		delete(fields, "displayName")

	}
	// Field "displayNameFromDS"
	if fields["displayNameFromDS"] != nil {
		if string(fields["displayNameFromDS"]) != "null" {
			if err := json.Unmarshal(fields["displayNameFromDS"], &resource.DisplayNameFromDS); err != nil {
				errs = append(errs, cog.MakeBuildErrors("displayNameFromDS", err)...)
			}

		}
		delete(fields, "displayNameFromDS")

	}
	// Field "description"
	if fields["description"] != nil {
		if string(fields["description"]) != "null" {
			if err := json.Unmarshal(fields["description"], &resource.Description); err != nil {
				errs = append(errs, cog.MakeBuildErrors("description", err)...)
			}

		}
		delete(fields, "description")

	}
	// Field "path"
	if fields["path"] != nil {
		if string(fields["path"]) != "null" {
			if err := json.Unmarshal(fields["path"], &resource.Path); err != nil {
				errs = append(errs, cog.MakeBuildErrors("path", err)...)
			}

		}
		delete(fields, "path")

	}
	// Field "writeable"
	if fields["writeable"] != nil {
		if string(fields["writeable"]) != "null" {
			if err := json.Unmarshal(fields["writeable"], &resource.Writeable); err != nil {
				errs = append(errs, cog.MakeBuildErrors("writeable", err)...)
			}

		}
		delete(fields, "writeable")

	}
	// Field "filterable"
	if fields["filterable"] != nil {
		if string(fields["filterable"]) != "null" {
			if err := json.Unmarshal(fields["filterable"], &resource.Filterable); err != nil {
				errs = append(errs, cog.MakeBuildErrors("filterable", err)...)
			}

		}
		delete(fields, "filterable")

	}
	// Field "unit"
	if fields["unit"] != nil {
		if string(fields["unit"]) != "null" {
			if err := json.Unmarshal(fields["unit"], &resource.Unit); err != nil {
				errs = append(errs, cog.MakeBuildErrors("unit", err)...)
			}

		}
		delete(fields, "unit")

	}
	// Field "decimals"
	if fields["decimals"] != nil {
		if string(fields["decimals"]) != "null" {
			if err := json.Unmarshal(fields["decimals"], &resource.Decimals); err != nil {
				errs = append(errs, cog.MakeBuildErrors("decimals", err)...)
			}

		}
		delete(fields, "decimals")

	}
	// Field "min"
	if fields["min"] != nil {
		if string(fields["min"]) != "null" {
			if err := json.Unmarshal(fields["min"], &resource.Min); err != nil {
				errs = append(errs, cog.MakeBuildErrors("min", err)...)
			}

		}
		delete(fields, "min")

	}
	// Field "max"
	if fields["max"] != nil {
		if string(fields["max"]) != "null" {
			if err := json.Unmarshal(fields["max"], &resource.Max); err != nil {
				errs = append(errs, cog.MakeBuildErrors("max", err)...)
			}

		}
		delete(fields, "max")

	}
	// Field "mappings"
	if fields["mappings"] != nil {
		if string(fields["mappings"]) != "null" {

			partialArray := []json.RawMessage{}
			if err := json.Unmarshal(fields["mappings"], &partialArray); err != nil {
				return err
			}

			for i1 := range partialArray {
				var result1 ValueMapping

				result1 = ValueMapping{}
				if err := result1.UnmarshalJSONStrict(partialArray[i1]); err != nil {
					errs = append(errs, cog.MakeBuildErrors("mappings["+strconv.Itoa(i1)+"]", err)...)
				}
				resource.Mappings = append(resource.Mappings, result1)
			}

		}
		delete(fields, "mappings")

	}
	// Field "thresholds"
	if fields["thresholds"] != nil {
		if string(fields["thresholds"]) != "null" {

			resource.Thresholds = &ThresholdsConfig{}
			if err := resource.Thresholds.UnmarshalJSONStrict(fields["thresholds"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("thresholds", err)...)
			}

		}
		delete(fields, "thresholds")

	}
	// Field "color"
	if fields["color"] != nil {
		if string(fields["color"]) != "null" {

			resource.Color = &FieldColor{}
			if err := resource.Color.UnmarshalJSONStrict(fields["color"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("color", err)...)
			}

		}
		delete(fields, "color")

	}
	// Field "links"
	if fields["links"] != nil {
		if string(fields["links"]) != "null" {

			if err := json.Unmarshal(fields["links"], &resource.Links); err != nil {
				errs = append(errs, cog.MakeBuildErrors("links", err)...)
			}

		}
		delete(fields, "links")

	}
	// Field "noValue"
	if fields["noValue"] != nil {
		if string(fields["noValue"]) != "null" {
			if err := json.Unmarshal(fields["noValue"], &resource.NoValue); err != nil {
				errs = append(errs, cog.MakeBuildErrors("noValue", err)...)
			}

		}
		delete(fields, "noValue")

	}
	// Field "custom"
	if fields["custom"] != nil {
		if string(fields["custom"]) != "null" {
			if err := json.Unmarshal(fields["custom"], &resource.Custom); err != nil {
				errs = append(errs, cog.MakeBuildErrors("custom", err)...)
			}

		}
		delete(fields, "custom")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("FieldConfig", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `FieldConfig` objects.
func (resource FieldConfig) Equals(other FieldConfig) bool {
	if resource.DisplayName == nil && other.DisplayName != nil || resource.DisplayName != nil && other.DisplayName == nil {
		return false
	}

	if resource.DisplayName != nil {
		if *resource.DisplayName != *other.DisplayName {
			return false
		}
	}
	if resource.DisplayNameFromDS == nil && other.DisplayNameFromDS != nil || resource.DisplayNameFromDS != nil && other.DisplayNameFromDS == nil {
		return false
	}

	if resource.DisplayNameFromDS != nil {
		if *resource.DisplayNameFromDS != *other.DisplayNameFromDS {
			return false
		}
	}
	if resource.Description == nil && other.Description != nil || resource.Description != nil && other.Description == nil {
		return false
	}

	if resource.Description != nil {
		if *resource.Description != *other.Description {
			return false
		}
	}
	if resource.Path == nil && other.Path != nil || resource.Path != nil && other.Path == nil {
		return false
	}

	if resource.Path != nil {
		if *resource.Path != *other.Path {
			return false
		}
	}
	if resource.Writeable == nil && other.Writeable != nil || resource.Writeable != nil && other.Writeable == nil {
		return false
	}

	if resource.Writeable != nil {
		if *resource.Writeable != *other.Writeable {
			return false
		}
	}
	if resource.Filterable == nil && other.Filterable != nil || resource.Filterable != nil && other.Filterable == nil {
		return false
	}

	if resource.Filterable != nil {
		if *resource.Filterable != *other.Filterable {
			return false
		}
	}
	if resource.Unit == nil && other.Unit != nil || resource.Unit != nil && other.Unit == nil {
		return false
	}

	if resource.Unit != nil {
		if *resource.Unit != *other.Unit {
			return false
		}
	}
	if resource.Decimals == nil && other.Decimals != nil || resource.Decimals != nil && other.Decimals == nil {
		return false
	}

	if resource.Decimals != nil {
		if *resource.Decimals != *other.Decimals {
			return false
		}
	}
	if resource.Min == nil && other.Min != nil || resource.Min != nil && other.Min == nil {
		return false
	}

	if resource.Min != nil {
		if *resource.Min != *other.Min {
			return false
		}
	}
	if resource.Max == nil && other.Max != nil || resource.Max != nil && other.Max == nil {
		return false
	}

	if resource.Max != nil {
		if *resource.Max != *other.Max {
			return false
		}
	}

	if len(resource.Mappings) != len(other.Mappings) {
		return false
	}

	for i1 := range resource.Mappings {
		if !resource.Mappings[i1].Equals(other.Mappings[i1]) {
			return false
		}
	}
	if resource.Thresholds == nil && other.Thresholds != nil || resource.Thresholds != nil && other.Thresholds == nil {
		return false
	}

	if resource.Thresholds != nil {
		if !resource.Thresholds.Equals(*other.Thresholds) {
			return false
		}
	}
	if resource.Color == nil && other.Color != nil || resource.Color != nil && other.Color == nil {
		return false
	}

	if resource.Color != nil {
		if !resource.Color.Equals(*other.Color) {
			return false
		}
	}

	if len(resource.Links) != len(other.Links) {
		return false
	}

	for i1 := range resource.Links {
		// is DeepEqual good enough here?
		if !reflect.DeepEqual(resource.Links[i1], other.Links[i1]) {
			return false
		}
	}
	if resource.NoValue == nil && other.NoValue != nil || resource.NoValue != nil && other.NoValue == nil {
		return false
	}

	if resource.NoValue != nil {
		if *resource.NoValue != *other.NoValue {
			return false
		}
	}
	// is DeepEqual good enough here?
	if !reflect.DeepEqual(resource.Custom, other.Custom) {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `FieldConfig` fields for violations and returns them.
func (resource FieldConfig) Validate() error {
	var errs cog.BuildErrors

	for i1 := range resource.Mappings {
		if err := resource.Mappings[i1].Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("mappings["+strconv.Itoa(i1)+"]", err)...)
		}
	}
	if resource.Thresholds != nil {
		if err := resource.Thresholds.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("thresholds", err)...)
		}
	}
	if resource.Color != nil {
		if err := resource.Color.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("color", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Row panel
type RowPanel struct {
	// The panel type
	Type string `json:"type"`
	// Whether this row should be collapsed or not.
	Collapsed bool `json:"collapsed"`
	// Row title
	Title *string `json:"title,omitempty"`
	// Name of default datasource for the row
	Datasource *DataSourceRef `json:"datasource,omitempty"`
	// Row grid position
	GridPos *GridPos `json:"gridPos,omitempty"`
	// Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
	Id uint32 `json:"id"`
	// List of panels in the row
	Panels []Panel `json:"panels"`
	// Name of template variable to repeat for.
	Repeat *string `json:"repeat,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `RowPanel` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *RowPanel) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "type"
	if fields["type"] != nil {
		if string(fields["type"]) != "null" {
			if err := json.Unmarshal(fields["type"], &resource.Type); err != nil {
				errs = append(errs, cog.MakeBuildErrors("type", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is null"))...)

		}
		delete(fields, "type")
	} else {
		errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is missing from input"))...)
	}
	// Field "collapsed"
	if fields["collapsed"] != nil {
		if string(fields["collapsed"]) != "null" {
			if err := json.Unmarshal(fields["collapsed"], &resource.Collapsed); err != nil {
				errs = append(errs, cog.MakeBuildErrors("collapsed", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("collapsed", errors.New("required field is null"))...)

		}
		delete(fields, "collapsed")
	} else {
		errs = append(errs, cog.MakeBuildErrors("collapsed", errors.New("required field is missing from input"))...)
	}
	// Field "title"
	if fields["title"] != nil {
		if string(fields["title"]) != "null" {
			if err := json.Unmarshal(fields["title"], &resource.Title); err != nil {
				errs = append(errs, cog.MakeBuildErrors("title", err)...)
			}

		}
		delete(fields, "title")

	}
	// Field "datasource"
	if fields["datasource"] != nil {
		if string(fields["datasource"]) != "null" {

			resource.Datasource = &DataSourceRef{}
			if err := resource.Datasource.UnmarshalJSONStrict(fields["datasource"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("datasource", err)...)
			}

		}
		delete(fields, "datasource")

	}
	// Field "gridPos"
	if fields["gridPos"] != nil {
		if string(fields["gridPos"]) != "null" {

			resource.GridPos = &GridPos{}
			if err := resource.GridPos.UnmarshalJSONStrict(fields["gridPos"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("gridPos", err)...)
			}

		}
		delete(fields, "gridPos")

	}
	// Field "id"
	if fields["id"] != nil {
		if string(fields["id"]) != "null" {
			if err := json.Unmarshal(fields["id"], &resource.Id); err != nil {
				errs = append(errs, cog.MakeBuildErrors("id", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("id", errors.New("required field is null"))...)

		}
		delete(fields, "id")
	} else {
		errs = append(errs, cog.MakeBuildErrors("id", errors.New("required field is missing from input"))...)
	}
	// Field "panels"
	if fields["panels"] != nil {
		if string(fields["panels"]) != "null" {

			partialArray := []json.RawMessage{}
			if err := json.Unmarshal(fields["panels"], &partialArray); err != nil {
				return err
			}

			for i1 := range partialArray {
				var result1 Panel

				result1 = Panel{}
				if err := result1.UnmarshalJSONStrict(partialArray[i1]); err != nil {
					errs = append(errs, cog.MakeBuildErrors("panels["+strconv.Itoa(i1)+"]", err)...)
				}
				resource.Panels = append(resource.Panels, result1)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("panels", errors.New("required field is null"))...)

		}
		delete(fields, "panels")
	} else {
		errs = append(errs, cog.MakeBuildErrors("panels", errors.New("required field is missing from input"))...)
	}
	// Field "repeat"
	if fields["repeat"] != nil {
		if string(fields["repeat"]) != "null" {
			if err := json.Unmarshal(fields["repeat"], &resource.Repeat); err != nil {
				errs = append(errs, cog.MakeBuildErrors("repeat", err)...)
			}

		}
		delete(fields, "repeat")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("RowPanel", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `RowPanel` objects.
func (resource RowPanel) Equals(other RowPanel) bool {
	if resource.Type != other.Type {
		return false
	}
	if resource.Collapsed != other.Collapsed {
		return false
	}
	if resource.Title == nil && other.Title != nil || resource.Title != nil && other.Title == nil {
		return false
	}

	if resource.Title != nil {
		if *resource.Title != *other.Title {
			return false
		}
	}
	if resource.Datasource == nil && other.Datasource != nil || resource.Datasource != nil && other.Datasource == nil {
		return false
	}

	if resource.Datasource != nil {
		if !resource.Datasource.Equals(*other.Datasource) {
			return false
		}
	}
	if resource.GridPos == nil && other.GridPos != nil || resource.GridPos != nil && other.GridPos == nil {
		return false
	}

	if resource.GridPos != nil {
		if !resource.GridPos.Equals(*other.GridPos) {
			return false
		}
	}
	if resource.Id != other.Id {
		return false
	}

	if len(resource.Panels) != len(other.Panels) {
		return false
	}

	for i1 := range resource.Panels {
		if !resource.Panels[i1].Equals(other.Panels[i1]) {
			return false
		}
	}
	if resource.Repeat == nil && other.Repeat != nil || resource.Repeat != nil && other.Repeat == nil {
		return false
	}

	if resource.Repeat != nil {
		if *resource.Repeat != *other.Repeat {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `RowPanel` fields for violations and returns them.
func (resource RowPanel) Validate() error {
	var errs cog.BuildErrors
	if resource.Datasource != nil {
		if err := resource.Datasource.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("datasource", err)...)
		}
	}
	if resource.GridPos != nil {
		if err := resource.GridPos.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("gridPos", err)...)
		}
	}

	for i1 := range resource.Panels {
		if err := resource.Panels[i1].Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("panels["+strconv.Itoa(i1)+"]", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Support for legacy graph panel.
// @deprecated this a deprecated panel type
type GraphPanel struct {
	Type string `json:"type"`
	// @deprecated this is part of deprecated graph panel
	Legend *DashboardGraphPanelLegend `json:"legend,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `GraphPanel` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *GraphPanel) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "type"
	if fields["type"] != nil {
		if string(fields["type"]) != "null" {
			if err := json.Unmarshal(fields["type"], &resource.Type); err != nil {
				errs = append(errs, cog.MakeBuildErrors("type", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is null"))...)

		}
		delete(fields, "type")
	} else {
		errs = append(errs, cog.MakeBuildErrors("type", errors.New("required field is missing from input"))...)
	}
	// Field "legend"
	if fields["legend"] != nil {
		if string(fields["legend"]) != "null" {

			resource.Legend = &DashboardGraphPanelLegend{}
			if err := resource.Legend.UnmarshalJSONStrict(fields["legend"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("legend", err)...)
			}

		}
		delete(fields, "legend")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("GraphPanel", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `GraphPanel` objects.
func (resource GraphPanel) Equals(other GraphPanel) bool {
	if resource.Type != other.Type {
		return false
	}
	if resource.Legend == nil && other.Legend != nil || resource.Legend != nil && other.Legend == nil {
		return false
	}

	if resource.Legend != nil {
		if !resource.Legend.Equals(*other.Legend) {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `GraphPanel` fields for violations and returns them.
func (resource GraphPanel) Validate() error {
	var errs cog.BuildErrors
	if resource.Legend != nil {
		if err := resource.Legend.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("legend", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

type TimePicker struct {
	// Whether timepicker is visible or not.
	Hidden bool `json:"hidden"`
	// Interval options available in the refresh picker dropdown.
	RefreshIntervals []string `json:"refresh_intervals"`
	// Whether timepicker is collapsed or not. Has no effect on provisioned dashboard.
	Collapse bool `json:"collapse"`
	// Whether timepicker is enabled or not. Has no effect on provisioned dashboard.
	Enable bool `json:"enable"`
	// Selectable options available in the time picker dropdown. Has no effect on provisioned dashboard.
	TimeOptions []string `json:"time_options"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `TimePicker` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *TimePicker) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "hidden"
	if fields["hidden"] != nil {
		if string(fields["hidden"]) != "null" {
			if err := json.Unmarshal(fields["hidden"], &resource.Hidden); err != nil {
				errs = append(errs, cog.MakeBuildErrors("hidden", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("hidden", errors.New("required field is null"))...)

		}
		delete(fields, "hidden")
	} else {
		errs = append(errs, cog.MakeBuildErrors("hidden", errors.New("required field is missing from input"))...)
	}
	// Field "refresh_intervals"
	if fields["refresh_intervals"] != nil {
		if string(fields["refresh_intervals"]) != "null" {

			if err := json.Unmarshal(fields["refresh_intervals"], &resource.RefreshIntervals); err != nil {
				errs = append(errs, cog.MakeBuildErrors("refresh_intervals", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("refresh_intervals", errors.New("required field is null"))...)

		}
		delete(fields, "refresh_intervals")
	} else {
		errs = append(errs, cog.MakeBuildErrors("refresh_intervals", errors.New("required field is missing from input"))...)
	}
	// Field "collapse"
	if fields["collapse"] != nil {
		if string(fields["collapse"]) != "null" {
			if err := json.Unmarshal(fields["collapse"], &resource.Collapse); err != nil {
				errs = append(errs, cog.MakeBuildErrors("collapse", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("collapse", errors.New("required field is null"))...)

		}
		delete(fields, "collapse")
	} else {
		errs = append(errs, cog.MakeBuildErrors("collapse", errors.New("required field is missing from input"))...)
	}
	// Field "enable"
	if fields["enable"] != nil {
		if string(fields["enable"]) != "null" {
			if err := json.Unmarshal(fields["enable"], &resource.Enable); err != nil {
				errs = append(errs, cog.MakeBuildErrors("enable", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("enable", errors.New("required field is null"))...)

		}
		delete(fields, "enable")
	} else {
		errs = append(errs, cog.MakeBuildErrors("enable", errors.New("required field is missing from input"))...)
	}
	// Field "time_options"
	if fields["time_options"] != nil {
		if string(fields["time_options"]) != "null" {

			if err := json.Unmarshal(fields["time_options"], &resource.TimeOptions); err != nil {
				errs = append(errs, cog.MakeBuildErrors("time_options", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("time_options", errors.New("required field is null"))...)

		}
		delete(fields, "time_options")
	} else {
		errs = append(errs, cog.MakeBuildErrors("time_options", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("TimePicker", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `TimePicker` objects.
func (resource TimePicker) Equals(other TimePicker) bool {
	if resource.Hidden != other.Hidden {
		return false
	}

	if len(resource.RefreshIntervals) != len(other.RefreshIntervals) {
		return false
	}

	for i1 := range resource.RefreshIntervals {
		if resource.RefreshIntervals[i1] != other.RefreshIntervals[i1] {
			return false
		}
	}
	if resource.Collapse != other.Collapse {
		return false
	}
	if resource.Enable != other.Enable {
		return false
	}

	if len(resource.TimeOptions) != len(other.TimeOptions) {
		return false
	}

	for i1 := range resource.TimeOptions {
		if resource.TimeOptions[i1] != other.TimeOptions[i1] {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `TimePicker` fields for violations and returns them.
func (resource TimePicker) Validate() error {
	return nil
}

type AnnotationActions struct {
	CanAdd    *bool `json:"canAdd,omitempty"`
	CanDelete *bool `json:"canDelete,omitempty"`
	CanEdit   *bool `json:"canEdit,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `AnnotationActions` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *AnnotationActions) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "canAdd"
	if fields["canAdd"] != nil {
		if string(fields["canAdd"]) != "null" {
			if err := json.Unmarshal(fields["canAdd"], &resource.CanAdd); err != nil {
				errs = append(errs, cog.MakeBuildErrors("canAdd", err)...)
			}

		}
		delete(fields, "canAdd")

	}
	// Field "canDelete"
	if fields["canDelete"] != nil {
		if string(fields["canDelete"]) != "null" {
			if err := json.Unmarshal(fields["canDelete"], &resource.CanDelete); err != nil {
				errs = append(errs, cog.MakeBuildErrors("canDelete", err)...)
			}

		}
		delete(fields, "canDelete")

	}
	// Field "canEdit"
	if fields["canEdit"] != nil {
		if string(fields["canEdit"]) != "null" {
			if err := json.Unmarshal(fields["canEdit"], &resource.CanEdit); err != nil {
				errs = append(errs, cog.MakeBuildErrors("canEdit", err)...)
			}

		}
		delete(fields, "canEdit")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("AnnotationActions", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `AnnotationActions` objects.
func (resource AnnotationActions) Equals(other AnnotationActions) bool {
	if resource.CanAdd == nil && other.CanAdd != nil || resource.CanAdd != nil && other.CanAdd == nil {
		return false
	}

	if resource.CanAdd != nil {
		if *resource.CanAdd != *other.CanAdd {
			return false
		}
	}
	if resource.CanDelete == nil && other.CanDelete != nil || resource.CanDelete != nil && other.CanDelete == nil {
		return false
	}

	if resource.CanDelete != nil {
		if *resource.CanDelete != *other.CanDelete {
			return false
		}
	}
	if resource.CanEdit == nil && other.CanEdit != nil || resource.CanEdit != nil && other.CanEdit == nil {
		return false
	}

	if resource.CanEdit != nil {
		if *resource.CanEdit != *other.CanEdit {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `AnnotationActions` fields for violations and returns them.
func (resource AnnotationActions) Validate() error {
	return nil
}

type AnnotationPermission struct {
	Dashboard    *AnnotationActions `json:"dashboard,omitempty"`
	Organization *AnnotationActions `json:"organization,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `AnnotationPermission` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *AnnotationPermission) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "dashboard"
	if fields["dashboard"] != nil {
		if string(fields["dashboard"]) != "null" {

			resource.Dashboard = &AnnotationActions{}
			if err := resource.Dashboard.UnmarshalJSONStrict(fields["dashboard"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("dashboard", err)...)
			}

		}
		delete(fields, "dashboard")

	}
	// Field "organization"
	if fields["organization"] != nil {
		if string(fields["organization"]) != "null" {

			resource.Organization = &AnnotationActions{}
			if err := resource.Organization.UnmarshalJSONStrict(fields["organization"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("organization", err)...)
			}

		}
		delete(fields, "organization")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("AnnotationPermission", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `AnnotationPermission` objects.
func (resource AnnotationPermission) Equals(other AnnotationPermission) bool {
	if resource.Dashboard == nil && other.Dashboard != nil || resource.Dashboard != nil && other.Dashboard == nil {
		return false
	}

	if resource.Dashboard != nil {
		if !resource.Dashboard.Equals(*other.Dashboard) {
			return false
		}
	}
	if resource.Organization == nil && other.Organization != nil || resource.Organization != nil && other.Organization == nil {
		return false
	}

	if resource.Organization != nil {
		if !resource.Organization.Equals(*other.Organization) {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `AnnotationPermission` fields for violations and returns them.
func (resource AnnotationPermission) Validate() error {
	var errs cog.BuildErrors
	if resource.Dashboard != nil {
		if err := resource.Dashboard.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("dashboard", err)...)
		}
	}
	if resource.Organization != nil {
		if err := resource.Organization.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("organization", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

type DashboardMeta struct {
	AnnotationsPermissions     *AnnotationPermission `json:"annotationsPermissions,omitempty"`
	CanAdmin                   *bool                 `json:"canAdmin,omitempty"`
	CanDelete                  *bool                 `json:"canDelete,omitempty"`
	CanEdit                    *bool                 `json:"canEdit,omitempty"`
	CanSave                    *bool                 `json:"canSave,omitempty"`
	CanStar                    *bool                 `json:"canStar,omitempty"`
	Created                    *time.Time            `json:"created,omitempty"`
	CreatedBy                  *string               `json:"createdBy,omitempty"`
	Expires                    *time.Time            `json:"expires,omitempty"`
	FolderId                   *int64                `json:"folderId,omitempty"`
	FolderTitle                *string               `json:"folderTitle,omitempty"`
	FolderUid                  *string               `json:"folderUid,omitempty"`
	FolderUrl                  *string               `json:"folderUrl,omitempty"`
	HasAcl                     *bool                 `json:"hasAcl,omitempty"`
	IsFolder                   *bool                 `json:"isFolder,omitempty"`
	IsSnapshot                 *bool                 `json:"isSnapshot,omitempty"`
	IsStarred                  *bool                 `json:"isStarred,omitempty"`
	Provisioned                *bool                 `json:"provisioned,omitempty"`
	ProvisionedExternalId      *string               `json:"provisionedExternalId,omitempty"`
	PublicDashboardAccessToken *string               `json:"publicDashboardAccessToken,omitempty"`
	PublicDashboardEnabled     *bool                 `json:"publicDashboardEnabled,omitempty"`
	PublicDashboardUid         *string               `json:"publicDashboardUid,omitempty"`
	Slug                       *string               `json:"slug,omitempty"`
	Type                       *string               `json:"type,omitempty"`
	Updated                    *time.Time            `json:"updated,omitempty"`
	UpdatedBy                  *string               `json:"updatedBy,omitempty"`
	Url                        *string               `json:"url,omitempty"`
	Version                    *int64                `json:"version,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `DashboardMeta` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *DashboardMeta) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "annotationsPermissions"
	if fields["annotationsPermissions"] != nil {
		if string(fields["annotationsPermissions"]) != "null" {

			resource.AnnotationsPermissions = &AnnotationPermission{}
			if err := resource.AnnotationsPermissions.UnmarshalJSONStrict(fields["annotationsPermissions"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("annotationsPermissions", err)...)
			}

		}
		delete(fields, "annotationsPermissions")

	}
	// Field "canAdmin"
	if fields["canAdmin"] != nil {
		if string(fields["canAdmin"]) != "null" {
			if err := json.Unmarshal(fields["canAdmin"], &resource.CanAdmin); err != nil {
				errs = append(errs, cog.MakeBuildErrors("canAdmin", err)...)
			}

		}
		delete(fields, "canAdmin")

	}
	// Field "canDelete"
	if fields["canDelete"] != nil {
		if string(fields["canDelete"]) != "null" {
			if err := json.Unmarshal(fields["canDelete"], &resource.CanDelete); err != nil {
				errs = append(errs, cog.MakeBuildErrors("canDelete", err)...)
			}

		}
		delete(fields, "canDelete")

	}
	// Field "canEdit"
	if fields["canEdit"] != nil {
		if string(fields["canEdit"]) != "null" {
			if err := json.Unmarshal(fields["canEdit"], &resource.CanEdit); err != nil {
				errs = append(errs, cog.MakeBuildErrors("canEdit", err)...)
			}

		}
		delete(fields, "canEdit")

	}
	// Field "canSave"
	if fields["canSave"] != nil {
		if string(fields["canSave"]) != "null" {
			if err := json.Unmarshal(fields["canSave"], &resource.CanSave); err != nil {
				errs = append(errs, cog.MakeBuildErrors("canSave", err)...)
			}

		}
		delete(fields, "canSave")

	}
	// Field "canStar"
	if fields["canStar"] != nil {
		if string(fields["canStar"]) != "null" {
			if err := json.Unmarshal(fields["canStar"], &resource.CanStar); err != nil {
				errs = append(errs, cog.MakeBuildErrors("canStar", err)...)
			}

		}
		delete(fields, "canStar")

	}
	// Field "created"
	if fields["created"] != nil {
		if string(fields["created"]) != "null" {
			if err := json.Unmarshal(fields["created"], &resource.Created); err != nil {
				errs = append(errs, cog.MakeBuildErrors("created", err)...)
			}

		}
		delete(fields, "created")

	}
	// Field "createdBy"
	if fields["createdBy"] != nil {
		if string(fields["createdBy"]) != "null" {
			if err := json.Unmarshal(fields["createdBy"], &resource.CreatedBy); err != nil {
				errs = append(errs, cog.MakeBuildErrors("createdBy", err)...)
			}

		}
		delete(fields, "createdBy")

	}
	// Field "expires"
	if fields["expires"] != nil {
		if string(fields["expires"]) != "null" {
			if err := json.Unmarshal(fields["expires"], &resource.Expires); err != nil {
				errs = append(errs, cog.MakeBuildErrors("expires", err)...)
			}

		}
		delete(fields, "expires")

	}
	// Field "folderId"
	if fields["folderId"] != nil {
		if string(fields["folderId"]) != "null" {
			if err := json.Unmarshal(fields["folderId"], &resource.FolderId); err != nil {
				errs = append(errs, cog.MakeBuildErrors("folderId", err)...)
			}

		}
		delete(fields, "folderId")

	}
	// Field "folderTitle"
	if fields["folderTitle"] != nil {
		if string(fields["folderTitle"]) != "null" {
			if err := json.Unmarshal(fields["folderTitle"], &resource.FolderTitle); err != nil {
				errs = append(errs, cog.MakeBuildErrors("folderTitle", err)...)
			}

		}
		delete(fields, "folderTitle")

	}
	// Field "folderUid"
	if fields["folderUid"] != nil {
		if string(fields["folderUid"]) != "null" {
			if err := json.Unmarshal(fields["folderUid"], &resource.FolderUid); err != nil {
				errs = append(errs, cog.MakeBuildErrors("folderUid", err)...)
			}

		}
		delete(fields, "folderUid")

	}
	// Field "folderUrl"
	if fields["folderUrl"] != nil {
		if string(fields["folderUrl"]) != "null" {
			if err := json.Unmarshal(fields["folderUrl"], &resource.FolderUrl); err != nil {
				errs = append(errs, cog.MakeBuildErrors("folderUrl", err)...)
			}

		}
		delete(fields, "folderUrl")

	}
	// Field "hasAcl"
	if fields["hasAcl"] != nil {
		if string(fields["hasAcl"]) != "null" {
			if err := json.Unmarshal(fields["hasAcl"], &resource.HasAcl); err != nil {
				errs = append(errs, cog.MakeBuildErrors("hasAcl", err)...)
			}

		}
		delete(fields, "hasAcl")

	}
	// Field "isFolder"
	if fields["isFolder"] != nil {
		if string(fields["isFolder"]) != "null" {
			if err := json.Unmarshal(fields["isFolder"], &resource.IsFolder); err != nil {
				errs = append(errs, cog.MakeBuildErrors("isFolder", err)...)
			}

		}
		delete(fields, "isFolder")

	}
	// Field "isSnapshot"
	if fields["isSnapshot"] != nil {
		if string(fields["isSnapshot"]) != "null" {
			if err := json.Unmarshal(fields["isSnapshot"], &resource.IsSnapshot); err != nil {
				errs = append(errs, cog.MakeBuildErrors("isSnapshot", err)...)
			}

		}
		delete(fields, "isSnapshot")

	}
	// Field "isStarred"
	if fields["isStarred"] != nil {
		if string(fields["isStarred"]) != "null" {
			if err := json.Unmarshal(fields["isStarred"], &resource.IsStarred); err != nil {
				errs = append(errs, cog.MakeBuildErrors("isStarred", err)...)
			}

		}
		delete(fields, "isStarred")

	}
	// Field "provisioned"
	if fields["provisioned"] != nil {
		if string(fields["provisioned"]) != "null" {
			if err := json.Unmarshal(fields["provisioned"], &resource.Provisioned); err != nil {
				errs = append(errs, cog.MakeBuildErrors("provisioned", err)...)
			}

		}
		delete(fields, "provisioned")

	}
	// Field "provisionedExternalId"
	if fields["provisionedExternalId"] != nil {
		if string(fields["provisionedExternalId"]) != "null" {
			if err := json.Unmarshal(fields["provisionedExternalId"], &resource.ProvisionedExternalId); err != nil {
				errs = append(errs, cog.MakeBuildErrors("provisionedExternalId", err)...)
			}

		}
		delete(fields, "provisionedExternalId")

	}
	// Field "publicDashboardAccessToken"
	if fields["publicDashboardAccessToken"] != nil {
		if string(fields["publicDashboardAccessToken"]) != "null" {
			if err := json.Unmarshal(fields["publicDashboardAccessToken"], &resource.PublicDashboardAccessToken); err != nil {
				errs = append(errs, cog.MakeBuildErrors("publicDashboardAccessToken", err)...)
			}

		}
		delete(fields, "publicDashboardAccessToken")

	}
	// Field "publicDashboardEnabled"
	if fields["publicDashboardEnabled"] != nil {
		if string(fields["publicDashboardEnabled"]) != "null" {
			if err := json.Unmarshal(fields["publicDashboardEnabled"], &resource.PublicDashboardEnabled); err != nil {
				errs = append(errs, cog.MakeBuildErrors("publicDashboardEnabled", err)...)
			}

		}
		delete(fields, "publicDashboardEnabled")

	}
	// Field "publicDashboardUid"
	if fields["publicDashboardUid"] != nil {
		if string(fields["publicDashboardUid"]) != "null" {
			if err := json.Unmarshal(fields["publicDashboardUid"], &resource.PublicDashboardUid); err != nil {
				errs = append(errs, cog.MakeBuildErrors("publicDashboardUid", err)...)
			}

		}
		delete(fields, "publicDashboardUid")

	}
	// Field "slug"
	if fields["slug"] != nil {
		if string(fields["slug"]) != "null" {
			if err := json.Unmarshal(fields["slug"], &resource.Slug); err != nil {
				errs = append(errs, cog.MakeBuildErrors("slug", err)...)
			}

		}
		delete(fields, "slug")

	}
	// Field "type"
	if fields["type"] != nil {
		if string(fields["type"]) != "null" {
			if err := json.Unmarshal(fields["type"], &resource.Type); err != nil {
				errs = append(errs, cog.MakeBuildErrors("type", err)...)
			}

		}
		delete(fields, "type")

	}
	// Field "updated"
	if fields["updated"] != nil {
		if string(fields["updated"]) != "null" {
			if err := json.Unmarshal(fields["updated"], &resource.Updated); err != nil {
				errs = append(errs, cog.MakeBuildErrors("updated", err)...)
			}

		}
		delete(fields, "updated")

	}
	// Field "updatedBy"
	if fields["updatedBy"] != nil {
		if string(fields["updatedBy"]) != "null" {
			if err := json.Unmarshal(fields["updatedBy"], &resource.UpdatedBy); err != nil {
				errs = append(errs, cog.MakeBuildErrors("updatedBy", err)...)
			}

		}
		delete(fields, "updatedBy")

	}
	// Field "url"
	if fields["url"] != nil {
		if string(fields["url"]) != "null" {
			if err := json.Unmarshal(fields["url"], &resource.Url); err != nil {
				errs = append(errs, cog.MakeBuildErrors("url", err)...)
			}

		}
		delete(fields, "url")

	}
	// Field "version"
	if fields["version"] != nil {
		if string(fields["version"]) != "null" {
			if err := json.Unmarshal(fields["version"], &resource.Version); err != nil {
				errs = append(errs, cog.MakeBuildErrors("version", err)...)
			}

		}
		delete(fields, "version")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("DashboardMeta", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `DashboardMeta` objects.
func (resource DashboardMeta) Equals(other DashboardMeta) bool {
	if resource.AnnotationsPermissions == nil && other.AnnotationsPermissions != nil || resource.AnnotationsPermissions != nil && other.AnnotationsPermissions == nil {
		return false
	}

	if resource.AnnotationsPermissions != nil {
		if !resource.AnnotationsPermissions.Equals(*other.AnnotationsPermissions) {
			return false
		}
	}
	if resource.CanAdmin == nil && other.CanAdmin != nil || resource.CanAdmin != nil && other.CanAdmin == nil {
		return false
	}

	if resource.CanAdmin != nil {
		if *resource.CanAdmin != *other.CanAdmin {
			return false
		}
	}
	if resource.CanDelete == nil && other.CanDelete != nil || resource.CanDelete != nil && other.CanDelete == nil {
		return false
	}

	if resource.CanDelete != nil {
		if *resource.CanDelete != *other.CanDelete {
			return false
		}
	}
	if resource.CanEdit == nil && other.CanEdit != nil || resource.CanEdit != nil && other.CanEdit == nil {
		return false
	}

	if resource.CanEdit != nil {
		if *resource.CanEdit != *other.CanEdit {
			return false
		}
	}
	if resource.CanSave == nil && other.CanSave != nil || resource.CanSave != nil && other.CanSave == nil {
		return false
	}

	if resource.CanSave != nil {
		if *resource.CanSave != *other.CanSave {
			return false
		}
	}
	if resource.CanStar == nil && other.CanStar != nil || resource.CanStar != nil && other.CanStar == nil {
		return false
	}

	if resource.CanStar != nil {
		if *resource.CanStar != *other.CanStar {
			return false
		}
	}
	if resource.Created == nil && other.Created != nil || resource.Created != nil && other.Created == nil {
		return false
	}

	if resource.Created != nil {
		if *resource.Created != *other.Created {
			return false
		}
	}
	if resource.CreatedBy == nil && other.CreatedBy != nil || resource.CreatedBy != nil && other.CreatedBy == nil {
		return false
	}

	if resource.CreatedBy != nil {
		if *resource.CreatedBy != *other.CreatedBy {
			return false
		}
	}
	if resource.Expires == nil && other.Expires != nil || resource.Expires != nil && other.Expires == nil {
		return false
	}

	if resource.Expires != nil {
		if *resource.Expires != *other.Expires {
			return false
		}
	}
	if resource.FolderId == nil && other.FolderId != nil || resource.FolderId != nil && other.FolderId == nil {
		return false
	}

	if resource.FolderId != nil {
		if *resource.FolderId != *other.FolderId {
			return false
		}
	}
	if resource.FolderTitle == nil && other.FolderTitle != nil || resource.FolderTitle != nil && other.FolderTitle == nil {
		return false
	}

	if resource.FolderTitle != nil {
		if *resource.FolderTitle != *other.FolderTitle {
			return false
		}
	}
	if resource.FolderUid == nil && other.FolderUid != nil || resource.FolderUid != nil && other.FolderUid == nil {
		return false
	}

	if resource.FolderUid != nil {
		if *resource.FolderUid != *other.FolderUid {
			return false
		}
	}
	if resource.FolderUrl == nil && other.FolderUrl != nil || resource.FolderUrl != nil && other.FolderUrl == nil {
		return false
	}

	if resource.FolderUrl != nil {
		if *resource.FolderUrl != *other.FolderUrl {
			return false
		}
	}
	if resource.HasAcl == nil && other.HasAcl != nil || resource.HasAcl != nil && other.HasAcl == nil {
		return false
	}

	if resource.HasAcl != nil {
		if *resource.HasAcl != *other.HasAcl {
			return false
		}
	}
	if resource.IsFolder == nil && other.IsFolder != nil || resource.IsFolder != nil && other.IsFolder == nil {
		return false
	}

	if resource.IsFolder != nil {
		if *resource.IsFolder != *other.IsFolder {
			return false
		}
	}
	if resource.IsSnapshot == nil && other.IsSnapshot != nil || resource.IsSnapshot != nil && other.IsSnapshot == nil {
		return false
	}

	if resource.IsSnapshot != nil {
		if *resource.IsSnapshot != *other.IsSnapshot {
			return false
		}
	}
	if resource.IsStarred == nil && other.IsStarred != nil || resource.IsStarred != nil && other.IsStarred == nil {
		return false
	}

	if resource.IsStarred != nil {
		if *resource.IsStarred != *other.IsStarred {
			return false
		}
	}
	if resource.Provisioned == nil && other.Provisioned != nil || resource.Provisioned != nil && other.Provisioned == nil {
		return false
	}

	if resource.Provisioned != nil {
		if *resource.Provisioned != *other.Provisioned {
			return false
		}
	}
	if resource.ProvisionedExternalId == nil && other.ProvisionedExternalId != nil || resource.ProvisionedExternalId != nil && other.ProvisionedExternalId == nil {
		return false
	}

	if resource.ProvisionedExternalId != nil {
		if *resource.ProvisionedExternalId != *other.ProvisionedExternalId {
			return false
		}
	}
	if resource.PublicDashboardAccessToken == nil && other.PublicDashboardAccessToken != nil || resource.PublicDashboardAccessToken != nil && other.PublicDashboardAccessToken == nil {
		return false
	}

	if resource.PublicDashboardAccessToken != nil {
		if *resource.PublicDashboardAccessToken != *other.PublicDashboardAccessToken {
			return false
		}
	}
	if resource.PublicDashboardEnabled == nil && other.PublicDashboardEnabled != nil || resource.PublicDashboardEnabled != nil && other.PublicDashboardEnabled == nil {
		return false
	}

	if resource.PublicDashboardEnabled != nil {
		if *resource.PublicDashboardEnabled != *other.PublicDashboardEnabled {
			return false
		}
	}
	if resource.PublicDashboardUid == nil && other.PublicDashboardUid != nil || resource.PublicDashboardUid != nil && other.PublicDashboardUid == nil {
		return false
	}

	if resource.PublicDashboardUid != nil {
		if *resource.PublicDashboardUid != *other.PublicDashboardUid {
			return false
		}
	}
	if resource.Slug == nil && other.Slug != nil || resource.Slug != nil && other.Slug == nil {
		return false
	}

	if resource.Slug != nil {
		if *resource.Slug != *other.Slug {
			return false
		}
	}
	if resource.Type == nil && other.Type != nil || resource.Type != nil && other.Type == nil {
		return false
	}

	if resource.Type != nil {
		if *resource.Type != *other.Type {
			return false
		}
	}
	if resource.Updated == nil && other.Updated != nil || resource.Updated != nil && other.Updated == nil {
		return false
	}

	if resource.Updated != nil {
		if *resource.Updated != *other.Updated {
			return false
		}
	}
	if resource.UpdatedBy == nil && other.UpdatedBy != nil || resource.UpdatedBy != nil && other.UpdatedBy == nil {
		return false
	}

	if resource.UpdatedBy != nil {
		if *resource.UpdatedBy != *other.UpdatedBy {
			return false
		}
	}
	if resource.Url == nil && other.Url != nil || resource.Url != nil && other.Url == nil {
		return false
	}

	if resource.Url != nil {
		if *resource.Url != *other.Url {
			return false
		}
	}
	if resource.Version == nil && other.Version != nil || resource.Version != nil && other.Version == nil {
		return false
	}

	if resource.Version != nil {
		if *resource.Version != *other.Version {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `DashboardMeta` fields for violations and returns them.
func (resource DashboardMeta) Validate() error {
	var errs cog.BuildErrors
	if resource.AnnotationsPermissions != nil {
		if err := resource.AnnotationsPermissions.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("annotationsPermissions", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

type DashboardStyle string

const (
	DashboardStyleLight DashboardStyle = "light"
	DashboardStyleDark  DashboardStyle = "dark"
)

type PanelRepeatDirection string

const (
	PanelRepeatDirectionH PanelRepeatDirection = "h"
	PanelRepeatDirectionV PanelRepeatDirection = "v"
)

type DashboardDashboardTime struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `DashboardDashboardTime` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *DashboardDashboardTime) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "from"
	if fields["from"] != nil {
		if string(fields["from"]) != "null" {
			if err := json.Unmarshal(fields["from"], &resource.From); err != nil {
				errs = append(errs, cog.MakeBuildErrors("from", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("from", errors.New("required field is null"))...)

		}
		delete(fields, "from")
	} else {
		errs = append(errs, cog.MakeBuildErrors("from", errors.New("required field is missing from input"))...)
	}
	// Field "to"
	if fields["to"] != nil {
		if string(fields["to"]) != "null" {
			if err := json.Unmarshal(fields["to"], &resource.To); err != nil {
				errs = append(errs, cog.MakeBuildErrors("to", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("to", errors.New("required field is null"))...)

		}
		delete(fields, "to")
	} else {
		errs = append(errs, cog.MakeBuildErrors("to", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("DashboardDashboardTime", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `DashboardDashboardTime` objects.
func (resource DashboardDashboardTime) Equals(other DashboardDashboardTime) bool {
	if resource.From != other.From {
		return false
	}
	if resource.To != other.To {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `DashboardDashboardTime` fields for violations and returns them.
func (resource DashboardDashboardTime) Validate() error {
	return nil
}

type DashboardDashboardTemplating struct {
	// List of configured template variables with their saved values along with some other metadata
	List []VariableModel `json:"list,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `DashboardDashboardTemplating` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *DashboardDashboardTemplating) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "list"
	if fields["list"] != nil {
		if string(fields["list"]) != "null" {

			partialArray := []json.RawMessage{}
			if err := json.Unmarshal(fields["list"], &partialArray); err != nil {
				return err
			}

			for i1 := range partialArray {
				var result1 VariableModel

				result1 = VariableModel{}
				if err := result1.UnmarshalJSONStrict(partialArray[i1]); err != nil {
					errs = append(errs, cog.MakeBuildErrors("list["+strconv.Itoa(i1)+"]", err)...)
				}
				resource.List = append(resource.List, result1)
			}

		}
		delete(fields, "list")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("DashboardDashboardTemplating", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `DashboardDashboardTemplating` objects.
func (resource DashboardDashboardTemplating) Equals(other DashboardDashboardTemplating) bool {

	if len(resource.List) != len(other.List) {
		return false
	}

	for i1 := range resource.List {
		if !resource.List[i1].Equals(other.List[i1]) {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `DashboardDashboardTemplating` fields for violations and returns them.
func (resource DashboardDashboardTemplating) Validate() error {
	var errs cog.BuildErrors

	for i1 := range resource.List {
		if err := resource.List[i1].Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("list["+strconv.Itoa(i1)+"]", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

type DashboardRangeMapOptions struct {
	// Min value of the range. It can be null which means -Infinity
	From *float64 `json:"from"`
	// Max value of the range. It can be null which means +Infinity
	To *float64 `json:"to"`
	// Config to apply when the value is within the range
	Result ValueMappingResult `json:"result"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `DashboardRangeMapOptions` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *DashboardRangeMapOptions) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "from"
	if fields["from"] != nil {
		if string(fields["from"]) != "null" {
			if err := json.Unmarshal(fields["from"], &resource.From); err != nil {
				errs = append(errs, cog.MakeBuildErrors("from", err)...)
			}

		}
		delete(fields, "from")
	} else {
		errs = append(errs, cog.MakeBuildErrors("from", errors.New("required field is missing from input"))...)
	}
	// Field "to"
	if fields["to"] != nil {
		if string(fields["to"]) != "null" {
			if err := json.Unmarshal(fields["to"], &resource.To); err != nil {
				errs = append(errs, cog.MakeBuildErrors("to", err)...)
			}

		}
		delete(fields, "to")
	} else {
		errs = append(errs, cog.MakeBuildErrors("to", errors.New("required field is missing from input"))...)
	}
	// Field "result"
	if fields["result"] != nil {
		if string(fields["result"]) != "null" {

			resource.Result = ValueMappingResult{}
			if err := resource.Result.UnmarshalJSONStrict(fields["result"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("result", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("result", errors.New("required field is null"))...)

		}
		delete(fields, "result")
	} else {
		errs = append(errs, cog.MakeBuildErrors("result", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("DashboardRangeMapOptions", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `DashboardRangeMapOptions` objects.
func (resource DashboardRangeMapOptions) Equals(other DashboardRangeMapOptions) bool {
	if resource.From == nil && other.From != nil || resource.From != nil && other.From == nil {
		return false
	}

	if resource.From != nil {
		if *resource.From != *other.From {
			return false
		}
	}
	if resource.To == nil && other.To != nil || resource.To != nil && other.To == nil {
		return false
	}

	if resource.To != nil {
		if *resource.To != *other.To {
			return false
		}
	}
	if !resource.Result.Equals(other.Result) {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `DashboardRangeMapOptions` fields for violations and returns them.
func (resource DashboardRangeMapOptions) Validate() error {
	var errs cog.BuildErrors
	if err := resource.Result.Validate(); err != nil {
		errs = append(errs, cog.MakeBuildErrors("result", err)...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

type DashboardRegexMapOptions struct {
	// Regular expression to match against
	Pattern string `json:"pattern"`
	// Config to apply when the value matches the regex
	Result ValueMappingResult `json:"result"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `DashboardRegexMapOptions` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *DashboardRegexMapOptions) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "pattern"
	if fields["pattern"] != nil {
		if string(fields["pattern"]) != "null" {
			if err := json.Unmarshal(fields["pattern"], &resource.Pattern); err != nil {
				errs = append(errs, cog.MakeBuildErrors("pattern", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("pattern", errors.New("required field is null"))...)

		}
		delete(fields, "pattern")
	} else {
		errs = append(errs, cog.MakeBuildErrors("pattern", errors.New("required field is missing from input"))...)
	}
	// Field "result"
	if fields["result"] != nil {
		if string(fields["result"]) != "null" {

			resource.Result = ValueMappingResult{}
			if err := resource.Result.UnmarshalJSONStrict(fields["result"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("result", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("result", errors.New("required field is null"))...)

		}
		delete(fields, "result")
	} else {
		errs = append(errs, cog.MakeBuildErrors("result", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("DashboardRegexMapOptions", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `DashboardRegexMapOptions` objects.
func (resource DashboardRegexMapOptions) Equals(other DashboardRegexMapOptions) bool {
	if resource.Pattern != other.Pattern {
		return false
	}
	if !resource.Result.Equals(other.Result) {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `DashboardRegexMapOptions` fields for violations and returns them.
func (resource DashboardRegexMapOptions) Validate() error {
	var errs cog.BuildErrors
	if err := resource.Result.Validate(); err != nil {
		errs = append(errs, cog.MakeBuildErrors("result", err)...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

type DashboardSpecialValueMapOptions struct {
	// Special value to match against
	Match SpecialValueMatch `json:"match"`
	// Config to apply when the value matches the special value
	Result ValueMappingResult `json:"result"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `DashboardSpecialValueMapOptions` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *DashboardSpecialValueMapOptions) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "match"
	if fields["match"] != nil {
		if string(fields["match"]) != "null" {
			if err := json.Unmarshal(fields["match"], &resource.Match); err != nil {
				errs = append(errs, cog.MakeBuildErrors("match", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("match", errors.New("required field is null"))...)

		}
		delete(fields, "match")
	} else {
		errs = append(errs, cog.MakeBuildErrors("match", errors.New("required field is missing from input"))...)
	}
	// Field "result"
	if fields["result"] != nil {
		if string(fields["result"]) != "null" {

			resource.Result = ValueMappingResult{}
			if err := resource.Result.UnmarshalJSONStrict(fields["result"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("result", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("result", errors.New("required field is null"))...)

		}
		delete(fields, "result")
	} else {
		errs = append(errs, cog.MakeBuildErrors("result", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("DashboardSpecialValueMapOptions", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `DashboardSpecialValueMapOptions` objects.
func (resource DashboardSpecialValueMapOptions) Equals(other DashboardSpecialValueMapOptions) bool {
	if resource.Match != other.Match {
		return false
	}
	if !resource.Result.Equals(other.Result) {
		return false
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `DashboardSpecialValueMapOptions` fields for violations and returns them.
func (resource DashboardSpecialValueMapOptions) Validate() error {
	var errs cog.BuildErrors
	if err := resource.Result.Validate(); err != nil {
		errs = append(errs, cog.MakeBuildErrors("result", err)...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

type DashboardFieldConfigSourceOverrides struct {
	Matcher    MatcherConfig        `json:"matcher"`
	Properties []DynamicConfigValue `json:"properties"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `DashboardFieldConfigSourceOverrides` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *DashboardFieldConfigSourceOverrides) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "matcher"
	if fields["matcher"] != nil {
		if string(fields["matcher"]) != "null" {

			resource.Matcher = MatcherConfig{}
			if err := resource.Matcher.UnmarshalJSONStrict(fields["matcher"]); err != nil {
				errs = append(errs, cog.MakeBuildErrors("matcher", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("matcher", errors.New("required field is null"))...)

		}
		delete(fields, "matcher")
	} else {
		errs = append(errs, cog.MakeBuildErrors("matcher", errors.New("required field is missing from input"))...)
	}
	// Field "properties"
	if fields["properties"] != nil {
		if string(fields["properties"]) != "null" {

			partialArray := []json.RawMessage{}
			if err := json.Unmarshal(fields["properties"], &partialArray); err != nil {
				return err
			}

			for i1 := range partialArray {
				var result1 DynamicConfigValue

				result1 = DynamicConfigValue{}
				if err := result1.UnmarshalJSONStrict(partialArray[i1]); err != nil {
					errs = append(errs, cog.MakeBuildErrors("properties["+strconv.Itoa(i1)+"]", err)...)
				}
				resource.Properties = append(resource.Properties, result1)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("properties", errors.New("required field is null"))...)

		}
		delete(fields, "properties")
	} else {
		errs = append(errs, cog.MakeBuildErrors("properties", errors.New("required field is missing from input"))...)
	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("DashboardFieldConfigSourceOverrides", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `DashboardFieldConfigSourceOverrides` objects.
func (resource DashboardFieldConfigSourceOverrides) Equals(other DashboardFieldConfigSourceOverrides) bool {
	if !resource.Matcher.Equals(other.Matcher) {
		return false
	}

	if len(resource.Properties) != len(other.Properties) {
		return false
	}

	for i1 := range resource.Properties {
		if !resource.Properties[i1].Equals(other.Properties[i1]) {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `DashboardFieldConfigSourceOverrides` fields for violations and returns them.
func (resource DashboardFieldConfigSourceOverrides) Validate() error {
	var errs cog.BuildErrors
	if err := resource.Matcher.Validate(); err != nil {
		errs = append(errs, cog.MakeBuildErrors("matcher", err)...)
	}

	for i1 := range resource.Properties {
		if err := resource.Properties[i1].Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("properties["+strconv.Itoa(i1)+"]", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

type DashboardGraphPanelLegend struct {
	Show     bool    `json:"show"`
	Sort     *string `json:"sort,omitempty"`
	SortDesc *bool   `json:"sortDesc,omitempty"`
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `DashboardGraphPanelLegend` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *DashboardGraphPanelLegend) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	// Field "show"
	if fields["show"] != nil {
		if string(fields["show"]) != "null" {
			if err := json.Unmarshal(fields["show"], &resource.Show); err != nil {
				errs = append(errs, cog.MakeBuildErrors("show", err)...)
			}
		} else {
			errs = append(errs, cog.MakeBuildErrors("show", errors.New("required field is null"))...)

		}
		delete(fields, "show")
	} else {
		errs = append(errs, cog.MakeBuildErrors("show", errors.New("required field is missing from input"))...)
	}
	// Field "sort"
	if fields["sort"] != nil {
		if string(fields["sort"]) != "null" {
			if err := json.Unmarshal(fields["sort"], &resource.Sort); err != nil {
				errs = append(errs, cog.MakeBuildErrors("sort", err)...)
			}

		}
		delete(fields, "sort")

	}
	// Field "sortDesc"
	if fields["sortDesc"] != nil {
		if string(fields["sortDesc"]) != "null" {
			if err := json.Unmarshal(fields["sortDesc"], &resource.SortDesc); err != nil {
				errs = append(errs, cog.MakeBuildErrors("sortDesc", err)...)
			}

		}
		delete(fields, "sortDesc")

	}

	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("DashboardGraphPanelLegend", fmt.Errorf("unexpected field '%s'", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `DashboardGraphPanelLegend` objects.
func (resource DashboardGraphPanelLegend) Equals(other DashboardGraphPanelLegend) bool {
	if resource.Show != other.Show {
		return false
	}
	if resource.Sort == nil && other.Sort != nil || resource.Sort != nil && other.Sort == nil {
		return false
	}

	if resource.Sort != nil {
		if *resource.Sort != *other.Sort {
			return false
		}
	}
	if resource.SortDesc == nil && other.SortDesc != nil || resource.SortDesc != nil && other.SortDesc == nil {
		return false
	}

	if resource.SortDesc != nil {
		if *resource.SortDesc != *other.SortDesc {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `DashboardGraphPanelLegend` fields for violations and returns them.
func (resource DashboardGraphPanelLegend) Validate() error {
	return nil
}

type StringOrBool struct {
	String *string `json:"String,omitempty"`
	Bool   *bool   `json:"Bool,omitempty"`
}

// MarshalJSON implements a custom JSON marshalling logic to encode `StringOrBool` as JSON.
func (resource StringOrBool) MarshalJSON() ([]byte, error) {
	if resource.String != nil {
		return json.Marshal(resource.String)
	}

	if resource.Bool != nil {
		return json.Marshal(resource.Bool)
	}

	return nil, fmt.Errorf("no value for disjunction of scalars")
}

// UnmarshalJSON implements a custom JSON unmarshalling logic to decode `StringOrBool` from JSON.
func (resource *StringOrBool) UnmarshalJSON(raw []byte) error {
	if raw == nil {
		return nil
	}

	var errList []error

	// String
	var String string
	if err := json.Unmarshal(raw, &String); err != nil {
		errList = append(errList, err)
		resource.String = nil
	} else {
		resource.String = &String
		return nil
	}

	// Bool
	var Bool bool
	if err := json.Unmarshal(raw, &Bool); err != nil {
		errList = append(errList, err)
		resource.Bool = nil
	} else {
		resource.Bool = &Bool
		return nil
	}

	return errors.Join(errList...)
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `StringOrBool` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *StringOrBool) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors
	var errList []error

	// String
	var String string

	if err := json.Unmarshal(raw, &String); err != nil {
		errList = append(errList, err)
	} else {
		resource.String = &String
		return nil
	}

	// Bool
	var Bool bool

	if err := json.Unmarshal(raw, &Bool); err != nil {
		errList = append(errList, err)
	} else {
		resource.Bool = &Bool
		return nil
	}

	if len(errList) != 0 {
		errs = append(errs, cog.MakeBuildErrors("StringOrBool", errors.Join(errList...))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `StringOrBool` objects.
func (resource StringOrBool) Equals(other StringOrBool) bool {
	if resource.String == nil && other.String != nil || resource.String != nil && other.String == nil {
		return false
	}

	if resource.String != nil {
		if *resource.String != *other.String {
			return false
		}
	}
	if resource.Bool == nil && other.Bool != nil || resource.Bool != nil && other.Bool == nil {
		return false
	}

	if resource.Bool != nil {
		if *resource.Bool != *other.Bool {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `StringOrBool` fields for violations and returns them.
func (resource StringOrBool) Validate() error {
	return nil
}

type PanelOrRowPanel struct {
	Panel    *Panel    `json:"Panel,omitempty"`
	RowPanel *RowPanel `json:"RowPanel,omitempty"`
}

// MarshalJSON implements a custom JSON marshalling logic to encode `PanelOrRowPanel` as JSON.
func (resource PanelOrRowPanel) MarshalJSON() ([]byte, error) {
	if resource.Panel != nil {
		return json.Marshal(resource.Panel)
	}
	if resource.RowPanel != nil {
		return json.Marshal(resource.RowPanel)
	}

	return nil, fmt.Errorf("no value for disjunction of refs")
}

// UnmarshalJSON implements a custom JSON unmarshalling logic to decode `PanelOrRowPanel` from JSON.
func (resource *PanelOrRowPanel) UnmarshalJSON(raw []byte) error {
	if raw == nil {
		return nil
	}

	// FIXME: this is wasteful, we need to find a more efficient way to unmarshal this.
	parsedAsMap := make(map[string]any)
	if err := json.Unmarshal(raw, &parsedAsMap); err != nil {
		return err
	}

	discriminator, found := parsedAsMap["type"]
	if !found {
		return errors.New("discriminator field 'type' not found in payload")
	}

	switch discriminator {
	default:
		var panel Panel
		if err := json.Unmarshal(raw, &panel); err != nil {
			return err
		}

		resource.Panel = &panel
		return nil
	case "row":
		var rowPanel RowPanel
		if err := json.Unmarshal(raw, &rowPanel); err != nil {
			return err
		}

		resource.RowPanel = &rowPanel
		return nil
	}

	return fmt.Errorf("could not unmarshal resource with `type = %v`", discriminator)
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `PanelOrRowPanel` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *PanelOrRowPanel) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	// FIXME: this is wasteful, we need to find a more efficient way to unmarshal this.
	parsedAsMap := make(map[string]any)
	if err := json.Unmarshal(raw, &parsedAsMap); err != nil {
		return err
	}

	discriminator, found := parsedAsMap["type"]
	if !found {
		return fmt.Errorf("discriminator field 'type' not found in payload")
	}

	switch discriminator {
	default:
		panel := &Panel{}
		if err := panel.UnmarshalJSONStrict(raw); err != nil {
			return err
		}

		resource.Panel = panel
		return nil
	case "row":
		rowPanel := &RowPanel{}
		if err := rowPanel.UnmarshalJSONStrict(raw); err != nil {
			return err
		}

		resource.RowPanel = rowPanel
		return nil
	}

	return fmt.Errorf("could not unmarshal resource with `type = %v`", discriminator)
}

// Equals tests the equality of two `PanelOrRowPanel` objects.
func (resource PanelOrRowPanel) Equals(other PanelOrRowPanel) bool {
	if resource.Panel == nil && other.Panel != nil || resource.Panel != nil && other.Panel == nil {
		return false
	}

	if resource.Panel != nil {
		if !resource.Panel.Equals(*other.Panel) {
			return false
		}
	}
	if resource.RowPanel == nil && other.RowPanel != nil || resource.RowPanel != nil && other.RowPanel == nil {
		return false
	}

	if resource.RowPanel != nil {
		if !resource.RowPanel.Equals(*other.RowPanel) {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `PanelOrRowPanel` fields for violations and returns them.
func (resource PanelOrRowPanel) Validate() error {
	var errs cog.BuildErrors
	if resource.Panel != nil {
		if err := resource.Panel.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("Panel", err)...)
		}
	}
	if resource.RowPanel != nil {
		if err := resource.RowPanel.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("RowPanel", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

type StringOrMap struct {
	String *string        `json:"String,omitempty"`
	Map    map[string]any `json:"Map,omitempty"`
}

// MarshalJSON implements a custom JSON marshalling logic to encode `StringOrMap` as JSON.
func (resource StringOrMap) MarshalJSON() ([]byte, error) {
	if resource.String != nil {
		return json.Marshal(resource.String)
	}

	if resource.Map != nil {
		return json.Marshal(resource.Map)
	}

	return nil, fmt.Errorf("no value for disjunction of scalars")
}

// UnmarshalJSON implements a custom JSON unmarshalling logic to decode `StringOrMap` from JSON.
func (resource *StringOrMap) UnmarshalJSON(raw []byte) error {
	if raw == nil {
		return nil
	}

	var errList []error

	// String
	var String string
	if err := json.Unmarshal(raw, &String); err != nil {
		errList = append(errList, err)
		resource.String = nil
	} else {
		resource.String = &String
		return nil
	}

	// Map
	var Map map[string]any
	if err := json.Unmarshal(raw, &Map); err != nil {
		errList = append(errList, err)
		resource.Map = nil
	} else {
		resource.Map = Map
		return nil
	}

	return errors.Join(errList...)
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `StringOrMap` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *StringOrMap) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors
	var errList []error

	// String
	var String string

	if err := json.Unmarshal(raw, &String); err != nil {
		errList = append(errList, err)
	} else {
		resource.String = &String
		return nil
	}

	// Map
	var Map map[string]any

	if err := json.Unmarshal(raw, &Map); err != nil {
		errList = append(errList, err)
	} else {
		resource.Map = Map
		return nil
	}

	if len(errList) != 0 {
		errs = append(errs, cog.MakeBuildErrors("StringOrMap", errors.Join(errList...))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `StringOrMap` objects.
func (resource StringOrMap) Equals(other StringOrMap) bool {
	if resource.String == nil && other.String != nil || resource.String != nil && other.String == nil {
		return false
	}

	if resource.String != nil {
		if *resource.String != *other.String {
			return false
		}
	}

	if len(resource.Map) != len(other.Map) {
		return false
	}

	for key1 := range resource.Map {
		// is DeepEqual good enough here?
		if !reflect.DeepEqual(resource.Map[key1], other.Map[key1]) {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `StringOrMap` fields for violations and returns them.
func (resource StringOrMap) Validate() error {
	return nil
}

type StringOrArrayOfString struct {
	String        *string  `json:"String,omitempty"`
	ArrayOfString []string `json:"ArrayOfString,omitempty"`
}

// MarshalJSON implements a custom JSON marshalling logic to encode `StringOrArrayOfString` as JSON.
func (resource StringOrArrayOfString) MarshalJSON() ([]byte, error) {
	if resource.String != nil {
		return json.Marshal(resource.String)
	}

	if resource.ArrayOfString != nil {
		return json.Marshal(resource.ArrayOfString)
	}

	return nil, fmt.Errorf("no value for disjunction of scalars")
}

// UnmarshalJSON implements a custom JSON unmarshalling logic to decode `StringOrArrayOfString` from JSON.
func (resource *StringOrArrayOfString) UnmarshalJSON(raw []byte) error {
	if raw == nil {
		return nil
	}

	var errList []error

	// String
	var String string
	if err := json.Unmarshal(raw, &String); err != nil {
		errList = append(errList, err)
		resource.String = nil
	} else {
		resource.String = &String
		return nil
	}

	// ArrayOfString
	var ArrayOfString []string
	if err := json.Unmarshal(raw, &ArrayOfString); err != nil {
		errList = append(errList, err)
		resource.ArrayOfString = nil
	} else {
		resource.ArrayOfString = ArrayOfString
		return nil
	}

	return errors.Join(errList...)
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `StringOrArrayOfString` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *StringOrArrayOfString) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	var errs cog.BuildErrors
	var errList []error

	// String
	var String string

	if err := json.Unmarshal(raw, &String); err != nil {
		errList = append(errList, err)
	} else {
		resource.String = &String
		return nil
	}

	// ArrayOfString
	var ArrayOfString []string

	if err := json.Unmarshal(raw, &ArrayOfString); err != nil {
		errList = append(errList, err)
	} else {
		resource.ArrayOfString = ArrayOfString
		return nil
	}

	if len(errList) != 0 {
		errs = append(errs, cog.MakeBuildErrors("StringOrArrayOfString", errors.Join(errList...))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

// Equals tests the equality of two `StringOrArrayOfString` objects.
func (resource StringOrArrayOfString) Equals(other StringOrArrayOfString) bool {
	if resource.String == nil && other.String != nil || resource.String != nil && other.String == nil {
		return false
	}

	if resource.String != nil {
		if *resource.String != *other.String {
			return false
		}
	}

	if len(resource.ArrayOfString) != len(other.ArrayOfString) {
		return false
	}

	for i1 := range resource.ArrayOfString {
		if resource.ArrayOfString[i1] != other.ArrayOfString[i1] {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `StringOrArrayOfString` fields for violations and returns them.
func (resource StringOrArrayOfString) Validate() error {
	return nil
}

type ValueMapOrRangeMapOrRegexMapOrSpecialValueMap struct {
	ValueMap        *ValueMap        `json:"ValueMap,omitempty"`
	RangeMap        *RangeMap        `json:"RangeMap,omitempty"`
	RegexMap        *RegexMap        `json:"RegexMap,omitempty"`
	SpecialValueMap *SpecialValueMap `json:"SpecialValueMap,omitempty"`
}

// MarshalJSON implements a custom JSON marshalling logic to encode `ValueMapOrRangeMapOrRegexMapOrSpecialValueMap` as JSON.
func (resource ValueMapOrRangeMapOrRegexMapOrSpecialValueMap) MarshalJSON() ([]byte, error) {
	if resource.ValueMap != nil {
		return json.Marshal(resource.ValueMap)
	}
	if resource.RangeMap != nil {
		return json.Marshal(resource.RangeMap)
	}
	if resource.RegexMap != nil {
		return json.Marshal(resource.RegexMap)
	}
	if resource.SpecialValueMap != nil {
		return json.Marshal(resource.SpecialValueMap)
	}

	return nil, fmt.Errorf("no value for disjunction of refs")
}

// UnmarshalJSON implements a custom JSON unmarshalling logic to decode `ValueMapOrRangeMapOrRegexMapOrSpecialValueMap` from JSON.
func (resource *ValueMapOrRangeMapOrRegexMapOrSpecialValueMap) UnmarshalJSON(raw []byte) error {
	if raw == nil {
		return nil
	}

	// FIXME: this is wasteful, we need to find a more efficient way to unmarshal this.
	parsedAsMap := make(map[string]any)
	if err := json.Unmarshal(raw, &parsedAsMap); err != nil {
		return err
	}

	discriminator, found := parsedAsMap["type"]
	if !found {
		return errors.New("discriminator field 'type' not found in payload")
	}

	switch discriminator {
	case "range":
		var rangeMap RangeMap
		if err := json.Unmarshal(raw, &rangeMap); err != nil {
			return err
		}

		resource.RangeMap = &rangeMap
		return nil
	case "regex":
		var regexMap RegexMap
		if err := json.Unmarshal(raw, &regexMap); err != nil {
			return err
		}

		resource.RegexMap = &regexMap
		return nil
	case "special":
		var specialValueMap SpecialValueMap
		if err := json.Unmarshal(raw, &specialValueMap); err != nil {
			return err
		}

		resource.SpecialValueMap = &specialValueMap
		return nil
	case "value":
		var valueMap ValueMap
		if err := json.Unmarshal(raw, &valueMap); err != nil {
			return err
		}

		resource.ValueMap = &valueMap
		return nil
	}

	return fmt.Errorf("could not unmarshal resource with `type = %v`", discriminator)
}

// UnmarshalJSONStrict implements a custom JSON unmarshalling logic to decode `ValueMapOrRangeMapOrRegexMapOrSpecialValueMap` from JSON.
// Note: the unmarshalling done by this function is strict. It will fail over required fields being absent from the input, fields having an incorrect type, unexpected fields being present, …
func (resource *ValueMapOrRangeMapOrRegexMapOrSpecialValueMap) UnmarshalJSONStrict(raw []byte) error {
	if raw == nil {
		return nil
	}
	// FIXME: this is wasteful, we need to find a more efficient way to unmarshal this.
	parsedAsMap := make(map[string]any)
	if err := json.Unmarshal(raw, &parsedAsMap); err != nil {
		return err
	}

	discriminator, found := parsedAsMap["type"]
	if !found {
		return fmt.Errorf("discriminator field 'type' not found in payload")
	}

	switch discriminator {
	case "range":
		rangeMap := &RangeMap{}
		if err := rangeMap.UnmarshalJSONStrict(raw); err != nil {
			return err
		}

		resource.RangeMap = rangeMap
		return nil
	case "regex":
		regexMap := &RegexMap{}
		if err := regexMap.UnmarshalJSONStrict(raw); err != nil {
			return err
		}

		resource.RegexMap = regexMap
		return nil
	case "special":
		specialValueMap := &SpecialValueMap{}
		if err := specialValueMap.UnmarshalJSONStrict(raw); err != nil {
			return err
		}

		resource.SpecialValueMap = specialValueMap
		return nil
	case "value":
		valueMap := &ValueMap{}
		if err := valueMap.UnmarshalJSONStrict(raw); err != nil {
			return err
		}

		resource.ValueMap = valueMap
		return nil
	}

	return fmt.Errorf("could not unmarshal resource with `type = %v`", discriminator)
}

// Equals tests the equality of two `ValueMapOrRangeMapOrRegexMapOrSpecialValueMap` objects.
func (resource ValueMapOrRangeMapOrRegexMapOrSpecialValueMap) Equals(other ValueMapOrRangeMapOrRegexMapOrSpecialValueMap) bool {
	if resource.ValueMap == nil && other.ValueMap != nil || resource.ValueMap != nil && other.ValueMap == nil {
		return false
	}

	if resource.ValueMap != nil {
		if !resource.ValueMap.Equals(*other.ValueMap) {
			return false
		}
	}
	if resource.RangeMap == nil && other.RangeMap != nil || resource.RangeMap != nil && other.RangeMap == nil {
		return false
	}

	if resource.RangeMap != nil {
		if !resource.RangeMap.Equals(*other.RangeMap) {
			return false
		}
	}
	if resource.RegexMap == nil && other.RegexMap != nil || resource.RegexMap != nil && other.RegexMap == nil {
		return false
	}

	if resource.RegexMap != nil {
		if !resource.RegexMap.Equals(*other.RegexMap) {
			return false
		}
	}
	if resource.SpecialValueMap == nil && other.SpecialValueMap != nil || resource.SpecialValueMap != nil && other.SpecialValueMap == nil {
		return false
	}

	if resource.SpecialValueMap != nil {
		if !resource.SpecialValueMap.Equals(*other.SpecialValueMap) {
			return false
		}
	}

	return true
}

// Validate checks all the validation constraints that may be defined on `ValueMapOrRangeMapOrRegexMapOrSpecialValueMap` fields for violations and returns them.
func (resource ValueMapOrRangeMapOrRegexMapOrSpecialValueMap) Validate() error {
	var errs cog.BuildErrors
	if resource.ValueMap != nil {
		if err := resource.ValueMap.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("ValueMap", err)...)
		}
	}
	if resource.RangeMap != nil {
		if err := resource.RangeMap.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("RangeMap", err)...)
		}
	}
	if resource.RegexMap != nil {
		if err := resource.RegexMap.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("RegexMap", err)...)
		}
	}
	if resource.SpecialValueMap != nil {
		if err := resource.SpecialValueMap.Validate(); err != nil {
			errs = append(errs, cog.MakeBuildErrors("SpecialValueMap", err)...)
		}
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}
