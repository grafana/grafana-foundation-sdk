# Code generated - EDITING IS FUTILE. DO NOT EDIT.

import typing
from ..cog import builder as cogbuilder
from ..models import dashboard
from ..cog import variants as cogvariants


class Dashboard(cogbuilder.Builder[dashboard.Dashboard]):    
    _internal: dashboard.Dashboard
    __current_y: int = 0
    __current_x: int = 0
    __last_panel_height: int = 0

    def __init__(self, title: typing.Optional[str]):
        self._internal = dashboard.Dashboard()        
        self._internal.title = title

    def build(self) -> dashboard.Dashboard:
        return self._internal    
    
    def id_val(self, id_val: int) -> typing.Self:    
        """
        Unique numeric identifier for the dashboard.
        `id` is internal to a specific Grafana instance. `uid` should be used to identify a dashboard across Grafana instances.
        """
            
        self._internal.id_val = id_val
    
        return self
    
    def uid(self, uid: str) -> typing.Self:    
        """
        Unique dashboard identifier that can be generated by anyone. string (8-40)
        """
            
        self._internal.uid = uid
    
        return self
    
    def title(self, title: str) -> typing.Self:    
        """
        Title of dashboard.
        """
            
        self._internal.title = title
    
        return self
    
    def description(self, description: str) -> typing.Self:    
        """
        Description of dashboard.
        """
            
        self._internal.description = description
    
        return self
    
    def revision(self, revision: int) -> typing.Self:    
        """
        This property should only be used in dashboards defined by plugins.  It is a quick check
        to see if the version has changed since the last time.
        """
            
        self._internal.revision = revision
    
        return self
    
    def gnet_id(self, gnet_id: str) -> typing.Self:    
        """
        ID of a dashboard imported from the https://grafana.com/grafana/dashboards/ portal
        """
            
        self._internal.gnet_id = gnet_id
    
        return self
    
    def tags(self, tags: list[str]) -> typing.Self:    
        """
        Tags associated with dashboard.
        """
            
        self._internal.tags = tags
    
        return self
    
    def style(self, style: typing.Literal["light", "dark"]) -> typing.Self:    
        """
        Theme of dashboard.
        Default value: dark.
        """
            
        self._internal.style = style
    
        return self
    
    def timezone(self, timezone: str) -> typing.Self:    
        """
        Timezone of dashboard. Accepted values are IANA TZDB zone ID or "browser" or "utc".
        """
            
        self._internal.timezone = timezone
    
        return self
    
    def editable(self) -> typing.Self:    
        """
        Whether a dashboard is editable or not.
        """
            
        self._internal.editable = True
    
        return self
    
    def readonly(self) -> typing.Self:    
        """
        Whether a dashboard is editable or not.
        """
            
        self._internal.editable = False
    
        return self
    
    def tooltip(self, graph_tooltip: dashboard.DashboardCursorSync) -> typing.Self:    
        """
        Configuration of dashboard cursor sync behavior.
        Accepted values are 0 (sync turned off), 1 (shared crosshair), 2 (shared crosshair and tooltip).
        """
            
        self._internal.graph_tooltip = graph_tooltip
    
        return self
    
    def time(self, from_val: str, to: str) -> typing.Self:    
        """
        Time range for dashboard.
        Accepted values are relative time strings like {from: 'now-6h', to: 'now'} or absolute time strings like {from: '2020-07-10T08:00:00.000Z', to: '2020-07-10T14:00:00.000Z'}.
        """
            
        if self._internal.time is None:
            self._internal.time = dashboard.DashboardDashboardTime()
        assert isinstance(self._internal.time, dashboard.DashboardDashboardTime)
        self._internal.time.from_val = from_val    
        if self._internal.time is None:
            self._internal.time = dashboard.DashboardDashboardTime()
        assert isinstance(self._internal.time, dashboard.DashboardDashboardTime)
        self._internal.time.to = to
    
        return self
    
    def timepicker(self, timepicker: cogbuilder.Builder[dashboard.TimePicker]) -> typing.Self:    
        """
        Configuration of the time picker shown at the top of a dashboard.
        """
            
        timepicker_resource = timepicker.build()
        self._internal.timepicker = timepicker_resource
    
        return self
    
    def fiscal_year_start_month(self, fiscal_year_start_month: int) -> typing.Self:    
        """
        The month that the fiscal year starts on.  0 = January, 11 = December
        """
            
        if not fiscal_year_start_month < 12:
            raise ValueError("fiscal_year_start_month must be < 12")
        self._internal.fiscal_year_start_month = fiscal_year_start_month
    
        return self
    
    def live_now(self, live_now: bool) -> typing.Self:    
        """
        When set to true, the dashboard will redraw panels at an interval matching the pixel width.
        This will keep data "moving left" regardless of the query refresh rate. This setting helps
        avoid dashboards presenting stale live data
        """
            
        self._internal.live_now = live_now
    
        return self
    
    def week_start(self, week_start: str) -> typing.Self:    
        """
        Day when the week starts. Expressed by the name of the day in lowercase, e.g. "monday".
        """
            
        self._internal.week_start = week_start
    
        return self
    
    def refresh(self, refresh: typing.Union[str, typing.Literal[False]]) -> typing.Self:    
        """
        Refresh rate of dashboard. Represented via interval string, e.g. "5s", "1m", "1h", "1d".
        """
            
        self._internal.refresh = refresh
    
        return self
    
    def version(self, version: int) -> typing.Self:    
        """
        Version of the dashboard, incremented each time the dashboard is updated.
        """
            
        self._internal.version = version
    
        return self
    
    def with_panel(self, panel: cogbuilder.Builder[dashboard.Panel]) -> typing.Self:        
        if self._internal.panels is None:
            self._internal.panels = []
        
        panel_resource = panel.build()
        
        if panel_resource.grid_pos is None:
            panel_resource.grid_pos = dashboard.GridPos()
        
        # The panel either has no position set, or it is the first panel of the dashboard.
        # In that case, we position it on the grid
        if panel_resource.grid_pos.x == 0 and panel_resource.grid_pos.y == 0:
            panel_resource.grid_pos.x = self.__current_x
            panel_resource.grid_pos.y = self.__current_y
        self._internal.panels.append(panel_resource)
        
        # Prepare the coordinates for the next panel
        self.__current_x += panel_resource.grid_pos.w
        self.__last_panel_height = max(self.__last_panel_height, panel_resource.grid_pos.h)
        
        # Check for grid width overflow?
        if self.__current_x >= 24:
            self.__current_x = 0
            self.__current_y += self.__last_panel_height
            self.__last_panel_height = 0
    
        return self
    
    def with_row(self, row_panel: cogbuilder.Builder[dashboard.RowPanel]) -> typing.Self:        
        if self._internal.panels is None:
            self._internal.panels = []
        
        row_panel_resource = row_panel.build()
        
        # Position the row on the grid
        if row_panel_resource.grid_pos is None or (row_panel_resource.grid_pos.x == 0 and row_panel_resource.grid_pos.y == 0):
            row_panel_resource.grid_pos = dashboard.GridPos(
                x=0,
                y=self.__current_y + self.__last_panel_height,
                h=1,
                w=24,
            )
        self._internal.panels.append(row_panel_resource)
        
        # Reset the state for the next row
        self.__current_x = 0
        self.__current_y = row_panel_resource.grid_pos.y + 1
        self.__last_panel_height = 0
        
        # Position the row's panels on the grid
        for panel in row_panel_resource.panels:
            # Position the panel on the grid
            if panel.grid_pos is None:
                panel.grid_pos = dashboard.GridPos()
        
            # The panel either has no position set, or it is the first panel of the dashboard.
            # In that case, we position it on the grid
            if panel.grid_pos.x == 0 and panel.grid_pos.y == 0:
                panel.grid_pos.x = self.__current_x
                panel.grid_pos.y = self.__current_y
        
            # Prepare the coordinates for the next panel
            self.__current_x += panel.grid_pos.w
            self.__last_panel_height = max(self.__last_panel_height, panel.grid_pos.h)
        
            # Check for grid width overflow?
            if self.__current_x >= 24:
                self.__current_x = 0
                self.__current_y += self.__last_panel_height
                self.__last_panel_height = 0
    
        return self
    
    def variables(self, list_val: list[cogbuilder.Builder[dashboard.VariableModel]]) -> typing.Self:    
        """
        Configured template variables
        """
            
        if self._internal.templating is None:
            self._internal.templating = dashboard.DashboardDashboardTemplating()
        assert isinstance(self._internal.templating, dashboard.DashboardDashboardTemplating)
        list_val_resources = [r1.build() for r1 in list_val]
        self._internal.templating.list_val = list_val_resources
    
        return self
    
    def with_variable(self, list_val: cogbuilder.Builder[dashboard.VariableModel]) -> typing.Self:    
        """
        Configured template variables
        """
            
        if self._internal.templating is None:
            self._internal.templating = dashboard.DashboardDashboardTemplating()
        assert isinstance(self._internal.templating, dashboard.DashboardDashboardTemplating)
        if self._internal.templating.list_val is None:
            self._internal.templating.list_val = []
        
        list_val_resource = list_val.build()
        self._internal.templating.list_val.append(list_val_resource)
    
        return self
    
    def annotations(self, list_val: list[cogbuilder.Builder[dashboard.AnnotationQuery]]) -> typing.Self:    
        """
        Contains the list of annotations that are associated with the dashboard.
        Annotations are used to overlay event markers and overlay event tags on graphs.
        Grafana comes with a native annotation store and the ability to add annotation events directly from the graph panel or via the HTTP API.
        See https://grafana.com/docs/grafana/latest/dashboards/build-dashboards/annotate-visualizations/
        """
            
        if self._internal.annotations is None:
            self._internal.annotations = dashboard.AnnotationContainer()
        assert isinstance(self._internal.annotations, dashboard.AnnotationContainer)
        list_val_resources = [r1.build() for r1 in list_val]
        self._internal.annotations.list_val = list_val_resources
    
        return self
    
    def annotation(self, list_val: cogbuilder.Builder[dashboard.AnnotationQuery]) -> typing.Self:    
        """
        Contains the list of annotations that are associated with the dashboard.
        Annotations are used to overlay event markers and overlay event tags on graphs.
        Grafana comes with a native annotation store and the ability to add annotation events directly from the graph panel or via the HTTP API.
        See https://grafana.com/docs/grafana/latest/dashboards/build-dashboards/annotate-visualizations/
        """
            
        if self._internal.annotations is None:
            self._internal.annotations = dashboard.AnnotationContainer()
        assert isinstance(self._internal.annotations, dashboard.AnnotationContainer)
        if self._internal.annotations.list_val is None:
            self._internal.annotations.list_val = []
        
        list_val_resource = list_val.build()
        self._internal.annotations.list_val.append(list_val_resource)
    
        return self
    
    def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
        """
        Links with references to other dashboards or external websites.
        """
            
        links_resources = [r1.build() for r1 in links]
        self._internal.links = links_resources
    
        return self
    
    def link(self, links: cogbuilder.Builder[dashboard.DashboardLink]) -> typing.Self:    
        """
        Links with references to other dashboards or external websites.
        """
            
        if self._internal.links is None:
            self._internal.links = []
        
        links_resource = links.build()
        self._internal.links.append(links_resource)
    
        return self
    
    def snapshot(self, snapshot: cogbuilder.Builder[dashboard.Snapshot]) -> typing.Self:    
        """
        Snapshot options. They are present only if the dashboard is a snapshot.
        """
            
        snapshot_resource = snapshot.build()
        self._internal.snapshot = snapshot_resource
    
        return self
    

class AnnotationTarget(cogbuilder.Builder[dashboard.AnnotationTarget]):    
    """
    TODO: this should be a regular DataQuery that depends on the selected dashboard
    these match the properties of the "grafana" datasouce that is default in most dashboards
    """
    
    _internal: dashboard.AnnotationTarget

    def __init__(self):
        self._internal = dashboard.AnnotationTarget()

    def build(self) -> dashboard.AnnotationTarget:
        return self._internal    
    
    def limit(self, limit: int) -> typing.Self:    
        """
        Only required/valid for the grafana datasource...
        but code+tests is already depending on it so hard to change
        """
            
        self._internal.limit = limit
    
        return self
    
    def match_any(self, match_any: bool) -> typing.Self:    
        """
        Only required/valid for the grafana datasource...
        but code+tests is already depending on it so hard to change
        """
            
        self._internal.match_any = match_any
    
        return self
    
    def tags(self, tags: list[str]) -> typing.Self:    
        """
        Only required/valid for the grafana datasource...
        but code+tests is already depending on it so hard to change
        """
            
        self._internal.tags = tags
    
        return self
    
    def type_val(self, type_val: str) -> typing.Self:    
        """
        Only required/valid for the grafana datasource...
        but code+tests is already depending on it so hard to change
        """
            
        self._internal.type_val = type_val
    
        return self
    

class AnnotationPanelFilter(cogbuilder.Builder[dashboard.AnnotationPanelFilter]):    
    _internal: dashboard.AnnotationPanelFilter

    def __init__(self):
        self._internal = dashboard.AnnotationPanelFilter()

    def build(self) -> dashboard.AnnotationPanelFilter:
        return self._internal    
    
    def exclude(self, exclude: bool) -> typing.Self:    
        """
        Should the specified panels be included or excluded
        """
            
        self._internal.exclude = exclude
    
        return self
    
    def ids(self, ids: list[int]) -> typing.Self:    
        """
        Panel IDs that should be included or excluded
        """
            
        self._internal.ids = ids
    
        return self
    

class AnnotationQuery(cogbuilder.Builder[dashboard.AnnotationQuery]):    
    """
    TODO docs
    FROM: AnnotationQuery in grafana-data/src/types/annotations.ts
    """
    
    _internal: dashboard.AnnotationQuery

    def __init__(self):
        self._internal = dashboard.AnnotationQuery()

    def build(self) -> dashboard.AnnotationQuery:
        return self._internal    
    
    def name(self, name: str) -> typing.Self:    
        """
        Name of annotation.
        """
            
        self._internal.name = name
    
        return self
    
    def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
        """
        Datasource where the annotations data is
        """
            
        self._internal.datasource = datasource
    
        return self
    
    def enable(self, enable: bool) -> typing.Self:    
        """
        When enabled the annotation query is issued with every dashboard refresh
        """
            
        self._internal.enable = enable
    
        return self
    
    def hide(self, hide: bool) -> typing.Self:    
        """
        Annotation queries can be toggled on or off at the top of the dashboard.
        When hide is true, the toggle is not shown in the dashboard.
        """
            
        self._internal.hide = hide
    
        return self
    
    def icon_color(self, icon_color: str) -> typing.Self:    
        """
        Color to use for the annotation event markers
        """
            
        self._internal.icon_color = icon_color
    
        return self
    
    def filter_val(self, filter_val: cogbuilder.Builder[dashboard.AnnotationPanelFilter]) -> typing.Self:    
        """
        Filters to apply when fetching annotations
        """
            
        filter_val_resource = filter_val.build()
        self._internal.filter_val = filter_val_resource
    
        return self
    
    def target(self, target: cogbuilder.Builder[dashboard.AnnotationTarget]) -> typing.Self:    
        """
        TODO.. this should just be a normal query target
        """
            
        target_resource = target.build()
        self._internal.target = target_resource
    
        return self
    
    def type_val(self, type_val: str) -> typing.Self:    
        """
        TODO -- this should not exist here, it is based on the --grafana-- datasource
        """
            
        self._internal.type_val = type_val
    
        return self
    

class DashboardLink(cogbuilder.Builder[dashboard.DashboardLink]):    
    """
    Links with references to other dashboards or external resources
    """
    
    _internal: dashboard.DashboardLink

    def __init__(self, title: str):
        self._internal = dashboard.DashboardLink()        
        self._internal.title = title

    def build(self) -> dashboard.DashboardLink:
        return self._internal    
    
    def title(self, title: str) -> typing.Self:    
        """
        Title to display with the link
        """
            
        self._internal.title = title
    
        return self
    
    def type_val(self, type_val: dashboard.DashboardLinkType) -> typing.Self:    
        """
        Link type. Accepted values are dashboards (to refer to another dashboard) and link (to refer to an external resource)
        """
            
        self._internal.type_val = type_val
    
        return self
    
    def icon(self, icon: str) -> typing.Self:    
        """
        Icon name to be displayed with the link
        """
            
        self._internal.icon = icon
    
        return self
    
    def tooltip(self, tooltip: str) -> typing.Self:    
        """
        Tooltip to display when the user hovers their mouse over it
        """
            
        self._internal.tooltip = tooltip
    
        return self
    
    def url(self, url: str) -> typing.Self:    
        """
        Link URL. Only required/valid if the type is link
        """
            
        self._internal.url = url
    
        return self
    
    def tags(self, tags: list[str]) -> typing.Self:    
        """
        List of tags to limit the linked dashboards. If empty, all dashboards will be displayed. Only valid if the type is dashboards
        """
            
        self._internal.tags = tags
    
        return self
    
    def as_dropdown(self, as_dropdown: bool) -> typing.Self:    
        """
        If true, all dashboards links will be displayed in a dropdown. If false, all dashboards links will be displayed side by side. Only valid if the type is dashboards
        """
            
        self._internal.as_dropdown = as_dropdown
    
        return self
    
    def target_blank(self, target_blank: bool) -> typing.Self:    
        """
        If true, the link will be opened in a new tab
        """
            
        self._internal.target_blank = target_blank
    
        return self
    
    def include_vars(self, include_vars: bool) -> typing.Self:    
        """
        If true, includes current template variables values in the link as query params
        """
            
        self._internal.include_vars = include_vars
    
        return self
    
    def keep_time(self, keep_time: bool) -> typing.Self:    
        """
        If true, includes current time range in the link as query params
        """
            
        self._internal.keep_time = keep_time
    
        return self
    

class FieldColor(cogbuilder.Builder[dashboard.FieldColor]):    
    """
    Map a field to a color.
    """
    
    _internal: dashboard.FieldColor

    def __init__(self):
        self._internal = dashboard.FieldColor()

    def build(self) -> dashboard.FieldColor:
        return self._internal    
    
    def mode(self, mode: dashboard.FieldColorModeId) -> typing.Self:    
        """
        The main color scheme mode.
        """
            
        self._internal.mode = mode
    
        return self
    
    def fixed_color(self, fixed_color: str) -> typing.Self:    
        """
        The fixed color value for fixed or shades color modes.
        """
            
        self._internal.fixed_color = fixed_color
    
        return self
    
    def series_by(self, series_by: dashboard.FieldColorSeriesByMode) -> typing.Self:    
        """
        Some visualizations need to know how to assign a series color from by value color schemes.
        """
            
        self._internal.series_by = series_by
    
        return self
    

class ThresholdsConfig(cogbuilder.Builder[dashboard.ThresholdsConfig]):    
    """
    Thresholds configuration for the panel
    """
    
    _internal: dashboard.ThresholdsConfig

    def __init__(self):
        self._internal = dashboard.ThresholdsConfig()

    def build(self) -> dashboard.ThresholdsConfig:
        return self._internal    
    
    def mode(self, mode: dashboard.ThresholdsMode) -> typing.Self:    
        """
        Thresholds mode.
        """
            
        self._internal.mode = mode
    
        return self
    
    def steps(self, steps: list[dashboard.Threshold]) -> typing.Self:    
        """
        Must be sorted by 'value', first value is always -Infinity
        """
            
        self._internal.steps = steps
    
        return self
    

class ValueMap(cogbuilder.Builder[dashboard.ValueMap]):    
    """
    Maps text values to a color or different display text and color.
    For example, you can configure a value mapping so that all instances of the value 10 appear as Perfection! rather than the number.
    """
    
    _internal: dashboard.ValueMap

    def __init__(self):
        self._internal = dashboard.ValueMap()        
        self._internal.type_val = "value"

    def build(self) -> dashboard.ValueMap:
        return self._internal    
    
    def options(self, options: dict[str, dashboard.ValueMappingResult]) -> typing.Self:    
        """
        Map with <value_to_match>: ValueMappingResult. For example: { "10": { text: "Perfection!", color: "green" } }
        """
            
        self._internal.options = options
    
        return self
    

class RangeMap(cogbuilder.Builder[dashboard.RangeMap]):    
    """
    Maps numerical ranges to a display text and color.
    For example, if a value is within a certain range, you can configure a range value mapping to display Low or High rather than the number.
    """
    
    _internal: dashboard.RangeMap

    def __init__(self):
        self._internal = dashboard.RangeMap()        
        self._internal.type_val = "range"

    def build(self) -> dashboard.RangeMap:
        return self._internal    
    
    def options(self, options: cogbuilder.Builder[dashboard.DashboardRangeMapOptions]) -> typing.Self:    
        """
        Range to match against and the result to apply when the value is within the range
        """
            
        options_resource = options.build()
        self._internal.options = options_resource
    
        return self
    

class RegexMap(cogbuilder.Builder[dashboard.RegexMap]):    
    """
    Maps regular expressions to replacement text and a color.
    For example, if a value is www.example.com, you can configure a regex value mapping so that Grafana displays www and truncates the domain.
    """
    
    _internal: dashboard.RegexMap

    def __init__(self):
        self._internal = dashboard.RegexMap()        
        self._internal.type_val = "regex"

    def build(self) -> dashboard.RegexMap:
        return self._internal    
    
    def options(self, options: cogbuilder.Builder[dashboard.DashboardRegexMapOptions]) -> typing.Self:    
        """
        Regular expression to match against and the result to apply when the value matches the regex
        """
            
        options_resource = options.build()
        self._internal.options = options_resource
    
        return self
    

class SpecialValueMap(cogbuilder.Builder[dashboard.SpecialValueMap]):    
    """
    Maps special values like Null, NaN (not a number), and boolean values like true and false to a display text and color.
    See SpecialValueMatch to see the list of special values.
    For example, you can configure a special value mapping so that null values appear as N/A.
    """
    
    _internal: dashboard.SpecialValueMap

    def __init__(self):
        self._internal = dashboard.SpecialValueMap()        
        self._internal.type_val = "special"

    def build(self) -> dashboard.SpecialValueMap:
        return self._internal    
    
    def options(self, options: cogbuilder.Builder[dashboard.DashboardSpecialValueMapOptions]) -> typing.Self:        
        options_resource = options.build()
        self._internal.options = options_resource
    
        return self
    

class Snapshot(cogbuilder.Builder[dashboard.Snapshot]):    
    """
    A dashboard snapshot shares an interactive dashboard publicly.
    It is a read-only version of a dashboard, and is not editable.
    It is possible to create a snapshot of a snapshot.
    Grafana strips away all sensitive information from the dashboard.
    Sensitive information stripped: queries (metric, template,annotation) and panel links.
    """
    
    _internal: dashboard.Snapshot

    def __init__(self):
        self._internal = dashboard.Snapshot()

    def build(self) -> dashboard.Snapshot:
        return self._internal    
    
    def expires(self, expires: str) -> typing.Self:    
        """
        Time when the snapshot expires, default is never to expire
        """
            
        self._internal.expires = expires
    
        return self
    
    def external(self, external: bool) -> typing.Self:    
        """
        Is the snapshot saved in an external grafana instance
        """
            
        self._internal.external = external
    
        return self
    
    def external_url(self, external_url: str) -> typing.Self:    
        """
        external url, if snapshot was shared in external grafana instance
        """
            
        self._internal.external_url = external_url
    
        return self
    
    def id_val(self, id_val: int) -> typing.Self:    
        """
        Unique identifier of the snapshot
        """
            
        self._internal.id_val = id_val
    
        return self
    
    def key(self, key: str) -> typing.Self:    
        """
        Optional, defined the unique key of the snapshot, required if external is true
        """
            
        self._internal.key = key
    
        return self
    
    def name(self, name: str) -> typing.Self:    
        """
        Optional, name of the snapshot
        """
            
        self._internal.name = name
    
        return self
    
    def org_id(self, org_id: int) -> typing.Self:    
        """
        org id of the snapshot
        """
            
        self._internal.org_id = org_id
    
        return self
    
    def url(self, url: str) -> typing.Self:    
        """
        url of the snapshot, if snapshot was shared internally
        """
            
        self._internal.url = url
    
        return self
    
    def dashboard(self, dashboard: cogbuilder.Builder[dashboard.Dashboard]) -> typing.Self:        
        dashboard_resource = dashboard.build()
        self._internal.dashboard = dashboard_resource
    
        return self
    

class Panel(cogbuilder.Builder[dashboard.Panel]):    
    """
    Dashboard panels are the basic visualization building blocks.
    """
    
    _internal: dashboard.Panel

    def __init__(self):
        self._internal = dashboard.Panel()

    def build(self) -> dashboard.Panel:
        return self._internal    
    
    def type_val(self, type_val: str) -> typing.Self:    
        """
        The panel plugin type id. This is used to find the plugin to display the panel.
        """
            
        if not len(type_val) >= 1:
            raise ValueError("len(type_val) must be >= 1")
        self._internal.type_val = type_val
    
        return self
    
    def id_val(self, id_val: int) -> typing.Self:    
        """
        Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
        """
            
        self._internal.id_val = id_val
    
        return self
    
    def targets(self, targets: list[cogbuilder.Builder[cogvariants.Dataquery]]) -> typing.Self:    
        """
        Depends on the panel plugin. See the plugin documentation for details.
        """
            
        targets_resources = [r1.build() for r1 in targets]
        self._internal.targets = targets_resources
    
        return self
    
    def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
        """
        Depends on the panel plugin. See the plugin documentation for details.
        """
            
        if self._internal.targets is None:
            self._internal.targets = []
        
        targets_resource = targets.build()
        self._internal.targets.append(targets_resource)
    
        return self
    
    def title(self, title: str) -> typing.Self:    
        """
        Panel title.
        """
            
        self._internal.title = title
    
        return self
    
    def description(self, description: str) -> typing.Self:    
        """
        Panel description.
        """
            
        self._internal.description = description
    
        return self
    
    def transparent(self, transparent: bool) -> typing.Self:    
        """
        Whether to display the panel without a background.
        """
            
        self._internal.transparent = transparent
    
        return self
    
    def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
        """
        The datasource used in all targets.
        """
            
        self._internal.datasource = datasource
    
        return self
    
    def grid_pos(self, grid_pos: dashboard.GridPos) -> typing.Self:    
        """
        Grid position.
        """
            
        self._internal.grid_pos = grid_pos
    
        return self
    
    def height(self, h: int) -> typing.Self:    
        """
        Panel height. The height is the number of rows from the top edge of the panel.
        """
            
        if not h > 0:
            raise ValueError("h must be > 0")
        if self._internal.grid_pos is None:
            self._internal.grid_pos = dashboard.GridPos()
        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
        self._internal.grid_pos.h = h
    
        return self
    
    def span(self, w: int) -> typing.Self:    
        """
        Panel width. The width is the number of columns from the left edge of the panel.
        """
            
        if not w > 0:
            raise ValueError("w must be > 0")
        if not w <= 24:
            raise ValueError("w must be <= 24")
        if self._internal.grid_pos is None:
            self._internal.grid_pos = dashboard.GridPos()
        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
        self._internal.grid_pos.w = w
    
        return self
    
    def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
        """
        Panel links.
        """
            
        links_resources = [r1.build() for r1 in links]
        self._internal.links = links_resources
    
        return self
    
    def repeat(self, repeat: str) -> typing.Self:    
        """
        Name of template variable to repeat for.
        """
            
        self._internal.repeat = repeat
    
        return self
    
    def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
        """
        Direction to repeat in if 'repeat' is set.
        `h` for horizontal, `v` for vertical.
        """
            
        self._internal.repeat_direction = repeat_direction
    
        return self
    
    def max_data_points(self, max_data_points: float) -> typing.Self:    
        """
        The maximum number of data points that the panel queries are retrieving.
        """
            
        self._internal.max_data_points = max_data_points
    
        return self
    
    def transformations(self, transformations: list[dashboard.DataTransformerConfig]) -> typing.Self:    
        """
        List of transformations that are applied to the panel data before rendering.
        When there are multiple transformations, Grafana applies them in the order they are listed.
        Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
        """
            
        self._internal.transformations = transformations
    
        return self
    
    def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
        """
        List of transformations that are applied to the panel data before rendering.
        When there are multiple transformations, Grafana applies them in the order they are listed.
        Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
        """
            
        if self._internal.transformations is None:
            self._internal.transformations = []
        
        self._internal.transformations.append(transformations)
    
        return self
    
    def interval(self, interval: str) -> typing.Self:    
        """
        The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
        This value must be formatted as a number followed by a valid time
        identifier like: "40s", "3d", etc.
        See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
        """
            
        self._internal.interval = interval
    
        return self
    
    def time_from(self, time_from: str) -> typing.Self:    
        """
        Overrides the relative time range for individual panels,
        which causes them to be different than what is selected in
        the dashboard time picker in the top-right corner of the dashboard. You can use this to show metrics from different
        time periods or days on the same dashboard.
        The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
        `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
        Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
        See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
        """
            
        self._internal.time_from = time_from
    
        return self
    
    def time_shift(self, time_shift: str) -> typing.Self:    
        """
        Overrides the time range for individual panels by shifting its start and end relative to the time picker.
        For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
        Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
        See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
        """
            
        self._internal.time_shift = time_shift
    
        return self
    
    def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
        """
        Dynamically load the panel
        """
            
        self._internal.library_panel = library_panel
    
        return self
    
    def display_name(self, display_name: str) -> typing.Self:    
        """
        The display value for this field.  This supports template variables blank is auto
        """
            
        if self._internal.field_config is None:
            self._internal.field_config = dashboard.FieldConfigSource()
        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
        if self._internal.field_config.defaults is None:
            self._internal.field_config.defaults = dashboard.FieldConfig()
        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
        self._internal.field_config.defaults.display_name = display_name
    
        return self
    
    def unit(self, unit: str) -> typing.Self:    
        """
        Unit a field should use. The unit you select is applied to all fields except time.
        You can use the units ID availables in Grafana or a custom unit.
        Available units in Grafana: https://github.com/grafana/grafana/blob/main/packages/grafana-data/src/valueFormats/categories.ts
        As custom unit, you can use the following formats:
        `suffix:<suffix>` for custom unit that should go after value.
        `prefix:<prefix>` for custom unit that should go before value.
        `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
        `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
        `count:<unit>` for a custom count unit.
        `currency:<unit>` for custom a currency unit.
        """
            
        if self._internal.field_config is None:
            self._internal.field_config = dashboard.FieldConfigSource()
        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
        if self._internal.field_config.defaults is None:
            self._internal.field_config.defaults = dashboard.FieldConfig()
        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
        self._internal.field_config.defaults.unit = unit
    
        return self
    
    def decimals(self, decimals: float) -> typing.Self:    
        """
        Specify the number of decimals Grafana includes in the rendered value.
        If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
        For example 1.1234 will display as 1.12 and 100.456 will display as 100.
        To display all decimals, set the unit to `String`.
        """
            
        if self._internal.field_config is None:
            self._internal.field_config = dashboard.FieldConfigSource()
        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
        if self._internal.field_config.defaults is None:
            self._internal.field_config.defaults = dashboard.FieldConfig()
        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
        self._internal.field_config.defaults.decimals = decimals
    
        return self
    
    def min_val(self, min_val: float) -> typing.Self:    
        """
        The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
        """
            
        if self._internal.field_config is None:
            self._internal.field_config = dashboard.FieldConfigSource()
        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
        if self._internal.field_config.defaults is None:
            self._internal.field_config.defaults = dashboard.FieldConfig()
        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
        self._internal.field_config.defaults.min_val = min_val
    
        return self
    
    def max_val(self, max_val: float) -> typing.Self:    
        """
        The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
        """
            
        if self._internal.field_config is None:
            self._internal.field_config = dashboard.FieldConfigSource()
        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
        if self._internal.field_config.defaults is None:
            self._internal.field_config.defaults = dashboard.FieldConfig()
        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
        self._internal.field_config.defaults.max_val = max_val
    
        return self
    
    def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
        """
        Convert input values into a display string
        """
            
        if self._internal.field_config is None:
            self._internal.field_config = dashboard.FieldConfigSource()
        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
        if self._internal.field_config.defaults is None:
            self._internal.field_config.defaults = dashboard.FieldConfig()
        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
        self._internal.field_config.defaults.mappings = mappings
    
        return self
    
    def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
        """
        Map numeric values to states
        """
            
        if self._internal.field_config is None:
            self._internal.field_config = dashboard.FieldConfigSource()
        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
        if self._internal.field_config.defaults is None:
            self._internal.field_config.defaults = dashboard.FieldConfig()
        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
        thresholds_resource = thresholds.build()
        self._internal.field_config.defaults.thresholds = thresholds_resource
    
        return self
    
    def color_scheme(self, color: cogbuilder.Builder[dashboard.FieldColor]) -> typing.Self:    
        """
        Panel color configuration
        """
            
        if self._internal.field_config is None:
            self._internal.field_config = dashboard.FieldConfigSource()
        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
        if self._internal.field_config.defaults is None:
            self._internal.field_config.defaults = dashboard.FieldConfig()
        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
        color_resource = color.build()
        self._internal.field_config.defaults.color = color_resource
    
        return self
    
    def no_value(self, no_value: str) -> typing.Self:    
        """
        Alternative to empty string
        """
            
        if self._internal.field_config is None:
            self._internal.field_config = dashboard.FieldConfigSource()
        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
        if self._internal.field_config.defaults is None:
            self._internal.field_config.defaults = dashboard.FieldConfig()
        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
        self._internal.field_config.defaults.no_value = no_value
    
        return self
    
    def overrides(self, overrides: list[cogbuilder.Builder[dashboard.DashboardFieldConfigSourceOverrides]]) -> typing.Self:    
        """
        Overrides are the options applied to specific fields overriding the defaults.
        """
            
        if self._internal.field_config is None:
            self._internal.field_config = dashboard.FieldConfigSource()
        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
        overrides_resources = [r1.build() for r1 in overrides]
        self._internal.field_config.overrides = overrides_resources
    
        return self
    
    def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
        """
        Overrides are the options applied to specific fields overriding the defaults.
        """
            
        if self._internal.field_config is None:
            self._internal.field_config = dashboard.FieldConfigSource()
        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
        if self._internal.field_config.overrides is None:
            self._internal.field_config.overrides = []
        
        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
            matcher=matcher,
            properties=properties,
        ))
    
        return self
    

class Row(cogbuilder.Builder[dashboard.RowPanel]):    
    """
    Row panel
    """
    
    _internal: dashboard.RowPanel

    def __init__(self, title: typing.Optional[str]):
        self._internal = dashboard.RowPanel()        
        self._internal.type_val = "row"        
        self._internal.title = title

    def build(self) -> dashboard.RowPanel:
        return self._internal    
    
    def collapsed(self, collapsed: bool) -> typing.Self:    
        """
        Whether this row should be collapsed or not.
        """
            
        self._internal.collapsed = collapsed
    
        return self
    
    def title(self, title: str) -> typing.Self:    
        """
        Row title
        """
            
        self._internal.title = title
    
        return self
    
    def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
        """
        Name of default datasource for the row
        """
            
        self._internal.datasource = datasource
    
        return self
    
    def grid_pos(self, grid_pos: dashboard.GridPos) -> typing.Self:    
        """
        Row grid position
        """
            
        self._internal.grid_pos = grid_pos
    
        return self
    
    def id_val(self, id_val: int) -> typing.Self:    
        """
        Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
        """
            
        self._internal.id_val = id_val
    
        return self
    
    def with_panel(self, panels: cogbuilder.Builder[dashboard.Panel]) -> typing.Self:    
        """
        List of panels in the row
        """
            
        if self._internal.panels is None:
            self._internal.panels = []
        
        panels_resource = panels.build()
        self._internal.panels.append(panels_resource)
    
        return self
    
    def repeat(self, repeat: str) -> typing.Self:    
        """
        Name of template variable to repeat for.
        """
            
        self._internal.repeat = repeat
    
        return self
    

class GraphPanel(cogbuilder.Builder[dashboard.GraphPanel]):    
    """
    Support for legacy graph panel.
    @deprecated this a deprecated panel type
    """
    
    _internal: dashboard.GraphPanel

    def __init__(self):
        self._internal = dashboard.GraphPanel()        
        self._internal.type_val = "graph"

    def build(self) -> dashboard.GraphPanel:
        return self._internal    
    
    def legend(self, legend: cogbuilder.Builder[dashboard.DashboardGraphPanelLegend]) -> typing.Self:    
        """
        @deprecated this is part of deprecated graph panel
        """
            
        legend_resource = legend.build()
        self._internal.legend = legend_resource
    
        return self
    

class TimePicker(cogbuilder.Builder[dashboard.TimePicker]):    
    _internal: dashboard.TimePicker

    def __init__(self):
        self._internal = dashboard.TimePicker()

    def build(self) -> dashboard.TimePicker:
        return self._internal    
    
    def hidden(self, hidden: bool) -> typing.Self:    
        """
        Whether timepicker is visible or not.
        """
            
        self._internal.hidden = hidden
    
        return self
    
    def refresh_intervals(self, refresh_intervals: list[str]) -> typing.Self:    
        """
        Interval options available in the refresh picker dropdown.
        """
            
        self._internal.refresh_intervals = refresh_intervals
    
        return self
    
    def collapse(self, collapse: bool) -> typing.Self:    
        """
        Whether timepicker is collapsed or not. Has no effect on provisioned dashboard.
        """
            
        self._internal.collapse = collapse
    
        return self
    
    def enable(self, enable: bool) -> typing.Self:    
        """
        Whether timepicker is enabled or not. Has no effect on provisioned dashboard.
        """
            
        self._internal.enable = enable
    
        return self
    
    def time_options(self, time_options: list[str]) -> typing.Self:    
        """
        Selectable options available in the time picker dropdown. Has no effect on provisioned dashboard.
        """
            
        self._internal.time_options = time_options
    
        return self
    

class AnnotationActions(cogbuilder.Builder[dashboard.AnnotationActions]):    
    _internal: dashboard.AnnotationActions

    def __init__(self):
        self._internal = dashboard.AnnotationActions()

    def build(self) -> dashboard.AnnotationActions:
        return self._internal    
    
    def can_add(self, can_add: bool) -> typing.Self:        
        self._internal.can_add = can_add
    
        return self
    
    def can_delete(self, can_delete: bool) -> typing.Self:        
        self._internal.can_delete = can_delete
    
        return self
    
    def can_edit(self, can_edit: bool) -> typing.Self:        
        self._internal.can_edit = can_edit
    
        return self
    

class AnnotationPermission(cogbuilder.Builder[dashboard.AnnotationPermission]):    
    _internal: dashboard.AnnotationPermission

    def __init__(self):
        self._internal = dashboard.AnnotationPermission()

    def build(self) -> dashboard.AnnotationPermission:
        return self._internal    
    
    def dashboard_permissions(self, dashboard: cogbuilder.Builder[dashboard.AnnotationActions]) -> typing.Self:        
        dashboard_resource = dashboard.build()
        self._internal.dashboard = dashboard_resource
    
        return self
    
    def organization_permissions(self, organization: cogbuilder.Builder[dashboard.AnnotationActions]) -> typing.Self:        
        organization_resource = organization.build()
        self._internal.organization = organization_resource
    
        return self
    

class DashboardMeta(cogbuilder.Builder[dashboard.DashboardMeta]):    
    _internal: dashboard.DashboardMeta

    def __init__(self):
        self._internal = dashboard.DashboardMeta()

    def build(self) -> dashboard.DashboardMeta:
        return self._internal    
    
    def annotations_permissions(self, annotations_permissions: cogbuilder.Builder[dashboard.AnnotationPermission]) -> typing.Self:        
        annotations_permissions_resource = annotations_permissions.build()
        self._internal.annotations_permissions = annotations_permissions_resource
    
        return self
    
    def can_admin(self, can_admin: bool) -> typing.Self:        
        self._internal.can_admin = can_admin
    
        return self
    
    def can_delete(self, can_delete: bool) -> typing.Self:        
        self._internal.can_delete = can_delete
    
        return self
    
    def can_edit(self, can_edit: bool) -> typing.Self:        
        self._internal.can_edit = can_edit
    
        return self
    
    def can_save(self, can_save: bool) -> typing.Self:        
        self._internal.can_save = can_save
    
        return self
    
    def can_star(self, can_star: bool) -> typing.Self:        
        self._internal.can_star = can_star
    
        return self
    
    def created(self, created: str) -> typing.Self:        
        self._internal.created = created
    
        return self
    
    def created_by(self, created_by: str) -> typing.Self:        
        self._internal.created_by = created_by
    
        return self
    
    def expires(self, expires: str) -> typing.Self:        
        self._internal.expires = expires
    
        return self
    
    def folder_id(self, folder_id: int) -> typing.Self:        
        self._internal.folder_id = folder_id
    
        return self
    
    def folder_title(self, folder_title: str) -> typing.Self:        
        self._internal.folder_title = folder_title
    
        return self
    
    def folder_uid(self, folder_uid: str) -> typing.Self:        
        self._internal.folder_uid = folder_uid
    
        return self
    
    def folder_url(self, folder_url: str) -> typing.Self:        
        self._internal.folder_url = folder_url
    
        return self
    
    def has_acl(self, has_acl: bool) -> typing.Self:        
        self._internal.has_acl = has_acl
    
        return self
    
    def is_folder(self, is_folder: bool) -> typing.Self:        
        self._internal.is_folder = is_folder
    
        return self
    
    def is_snapshot(self, is_snapshot: bool) -> typing.Self:        
        self._internal.is_snapshot = is_snapshot
    
        return self
    
    def is_starred(self, is_starred: bool) -> typing.Self:        
        self._internal.is_starred = is_starred
    
        return self
    
    def provisioned(self, provisioned: bool) -> typing.Self:        
        self._internal.provisioned = provisioned
    
        return self
    
    def provisioned_external_id(self, provisioned_external_id: str) -> typing.Self:        
        self._internal.provisioned_external_id = provisioned_external_id
    
        return self
    
    def public_dashboard_access_token(self, public_dashboard_access_token: str) -> typing.Self:        
        self._internal.public_dashboard_access_token = public_dashboard_access_token
    
        return self
    
    def public_dashboard_enabled(self, public_dashboard_enabled: bool) -> typing.Self:        
        self._internal.public_dashboard_enabled = public_dashboard_enabled
    
        return self
    
    def public_dashboard_uid(self, public_dashboard_uid: str) -> typing.Self:        
        self._internal.public_dashboard_uid = public_dashboard_uid
    
        return self
    
    def slug(self, slug: str) -> typing.Self:        
        self._internal.slug = slug
    
        return self
    
    def type_val(self, type_val: str) -> typing.Self:        
        self._internal.type_val = type_val
    
        return self
    
    def updated(self, updated: str) -> typing.Self:        
        self._internal.updated = updated
    
        return self
    
    def updated_by(self, updated_by: str) -> typing.Self:        
        self._internal.updated_by = updated_by
    
        return self
    
    def url(self, url: str) -> typing.Self:        
        self._internal.url = url
    
        return self
    
    def version(self, version: int) -> typing.Self:        
        self._internal.version = version
    
        return self
    

class DashboardDashboardTemplating(cogbuilder.Builder[dashboard.DashboardDashboardTemplating]):    
    _internal: dashboard.DashboardDashboardTemplating

    def __init__(self):
        self._internal = dashboard.DashboardDashboardTemplating()

    def build(self) -> dashboard.DashboardDashboardTemplating:
        return self._internal    
    
    def list_val(self, list_val: list[cogbuilder.Builder[dashboard.VariableModel]]) -> typing.Self:    
        """
        List of configured template variables with their saved values along with some other metadata
        """
            
        list_val_resources = [r1.build() for r1 in list_val]
        self._internal.list_val = list_val_resources
    
        return self
    

class DashboardRangeMapOptions(cogbuilder.Builder[dashboard.DashboardRangeMapOptions]):    
    _internal: dashboard.DashboardRangeMapOptions

    def __init__(self):
        self._internal = dashboard.DashboardRangeMapOptions()

    def build(self) -> dashboard.DashboardRangeMapOptions:
        return self._internal    
    
    def from_val(self, from_val: float) -> typing.Self:    
        """
        Min value of the range. It can be null which means -Infinity
        """
            
        self._internal.from_val = from_val
    
        return self
    
    def to(self, to: float) -> typing.Self:    
        """
        Max value of the range. It can be null which means +Infinity
        """
            
        self._internal.to = to
    
        return self
    
    def result(self, result: dashboard.ValueMappingResult) -> typing.Self:    
        """
        Config to apply when the value is within the range
        """
            
        self._internal.result = result
    
        return self
    

class DashboardRegexMapOptions(cogbuilder.Builder[dashboard.DashboardRegexMapOptions]):    
    _internal: dashboard.DashboardRegexMapOptions

    def __init__(self):
        self._internal = dashboard.DashboardRegexMapOptions()

    def build(self) -> dashboard.DashboardRegexMapOptions:
        return self._internal    
    
    def pattern(self, pattern: str) -> typing.Self:    
        """
        Regular expression to match against
        """
            
        self._internal.pattern = pattern
    
        return self
    
    def result(self, result: dashboard.ValueMappingResult) -> typing.Self:    
        """
        Config to apply when the value matches the regex
        """
            
        self._internal.result = result
    
        return self
    

class DashboardSpecialValueMapOptions(cogbuilder.Builder[dashboard.DashboardSpecialValueMapOptions]):    
    _internal: dashboard.DashboardSpecialValueMapOptions

    def __init__(self):
        self._internal = dashboard.DashboardSpecialValueMapOptions()

    def build(self) -> dashboard.DashboardSpecialValueMapOptions:
        return self._internal    
    
    def match(self, match: dashboard.SpecialValueMatch) -> typing.Self:    
        """
        Special value to match against
        """
            
        self._internal.match = match
    
        return self
    
    def result(self, result: dashboard.ValueMappingResult) -> typing.Self:    
        """
        Config to apply when the value matches the special value
        """
            
        self._internal.result = result
    
        return self
    

class DashboardFieldConfigSourceOverrides(cogbuilder.Builder[dashboard.DashboardFieldConfigSourceOverrides]):    
    _internal: dashboard.DashboardFieldConfigSourceOverrides

    def __init__(self):
        self._internal = dashboard.DashboardFieldConfigSourceOverrides()

    def build(self) -> dashboard.DashboardFieldConfigSourceOverrides:
        return self._internal    
    
    def matcher(self, matcher: dashboard.MatcherConfig) -> typing.Self:        
        self._internal.matcher = matcher
    
        return self
    
    def properties(self, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:        
        self._internal.properties = properties
    
        return self
    

class DashboardGraphPanelLegend(cogbuilder.Builder[dashboard.DashboardGraphPanelLegend]):    
    _internal: dashboard.DashboardGraphPanelLegend

    def __init__(self):
        self._internal = dashboard.DashboardGraphPanelLegend()

    def build(self) -> dashboard.DashboardGraphPanelLegend:
        return self._internal    
    
    def show(self, show: bool) -> typing.Self:        
        self._internal.show = show
    
        return self
    
    def sort(self, sort: str) -> typing.Self:        
        self._internal.sort = sort
    
        return self
    
    def sort_desc(self, sort_desc: bool) -> typing.Self:        
        self._internal.sort_desc = sort_desc
    
        return self
    

class QueryVariable(cogbuilder.Builder[dashboard.VariableModel]):    
    """
    A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
    """
    
    _internal: dashboard.VariableModel

    def __init__(self, name: str):
        self._internal = dashboard.VariableModel()        
        self._internal.name = name        
        self._internal.type_val = dashboard.VariableType.QUERY

    def build(self) -> dashboard.VariableModel:
        return self._internal    
    
    def id_val(self, id_val: str) -> typing.Self:    
        """
        Unique numeric identifier for the variable.
        """
            
        self._internal.id_val = id_val
    
        return self
    
    def name(self, name: str) -> typing.Self:    
        """
        Name of variable
        """
            
        self._internal.name = name
    
        return self
    
    def label(self, label: str) -> typing.Self:    
        """
        Optional display name
        """
            
        self._internal.label = label
    
        return self
    
    def hide(self, hide: dashboard.VariableHide) -> typing.Self:    
        """
        Visibility configuration for the variable
        """
            
        self._internal.hide = hide
    
        return self
    
    def description(self, description: str) -> typing.Self:    
        """
        Description of variable. It can be defined but `null`.
        """
            
        self._internal.description = description
    
        return self
    
    def query(self, query: typing.Union[str, dict[str, object]]) -> typing.Self:    
        """
        Query used to fetch values for a variable
        """
            
        self._internal.query = query
    
        return self
    
    def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
        """
        Data source used to fetch values for a variable. It can be defined but `null`.
        """
            
        self._internal.datasource = datasource
    
        return self
    
    def all_format(self, all_format: str) -> typing.Self:    
        """
        Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
        """
            
        self._internal.all_format = all_format
    
        return self
    
    def current(self, current: dashboard.VariableOption) -> typing.Self:    
        """
        Shows current selected variable text/value on the dashboard
        """
            
        self._internal.current = current
    
        return self
    
    def multi(self, multi: bool) -> typing.Self:    
        """
        Whether multiple values can be selected or not from variable value list
        """
            
        self._internal.multi = multi
    
        return self
    
    def options(self, options: list[dashboard.VariableOption]) -> typing.Self:    
        """
        Options that can be selected for a variable.
        """
            
        self._internal.options = options
    
        return self
    
    def refresh(self, refresh: dashboard.VariableRefresh) -> typing.Self:    
        """
        Options to config when to refresh a variable
        """
            
        self._internal.refresh = refresh
    
        return self
    
    def sort(self, sort: dashboard.VariableSort) -> typing.Self:    
        """
        Options sort order
        """
            
        self._internal.sort = sort
    
        return self
    
    def include_all(self, include_all: bool) -> typing.Self:    
        """
        Whether all value option is available or not
        """
            
        self._internal.include_all = include_all
    
        return self
    
    def all_value(self, all_value: str) -> typing.Self:    
        """
        Custom all value
        """
            
        self._internal.all_value = all_value
    
        return self
    
    def regex(self, regex: str) -> typing.Self:    
        """
        Optional field, if you want to extract part of a series name or metric node segment.
        Named capture groups can be used to separate the display text and value.
        """
            
        self._internal.regex = regex
    
        return self
    

class AdHocVariable(cogbuilder.Builder[dashboard.VariableModel]):    
    """
    A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
    """
    
    _internal: dashboard.VariableModel

    def __init__(self, name: str):
        self._internal = dashboard.VariableModel()        
        self._internal.name = name        
        self._internal.type_val = dashboard.VariableType.ADHOC

    def build(self) -> dashboard.VariableModel:
        return self._internal    
    
    def id_val(self, id_val: str) -> typing.Self:    
        """
        Unique numeric identifier for the variable.
        """
            
        self._internal.id_val = id_val
    
        return self
    
    def name(self, name: str) -> typing.Self:    
        """
        Name of variable
        """
            
        self._internal.name = name
    
        return self
    
    def label(self, label: str) -> typing.Self:    
        """
        Optional display name
        """
            
        self._internal.label = label
    
        return self
    
    def hide(self, hide: dashboard.VariableHide) -> typing.Self:    
        """
        Visibility configuration for the variable
        """
            
        self._internal.hide = hide
    
        return self
    
    def description(self, description: str) -> typing.Self:    
        """
        Description of variable. It can be defined but `null`.
        """
            
        self._internal.description = description
    
        return self
    
    def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
        """
        Data source used to fetch values for a variable. It can be defined but `null`.
        """
            
        self._internal.datasource = datasource
    
        return self
    
    def all_format(self, all_format: str) -> typing.Self:    
        """
        Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
        """
            
        self._internal.all_format = all_format
    
        return self
    

class ConstantVariable(cogbuilder.Builder[dashboard.VariableModel]):    
    """
    A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
    """
    
    _internal: dashboard.VariableModel

    def __init__(self, name: str):
        self._internal = dashboard.VariableModel()        
        self._internal.name = name        
        self._internal.type_val = dashboard.VariableType.CONSTANT

    def build(self) -> dashboard.VariableModel:
        return self._internal    
    
    def id_val(self, id_val: str) -> typing.Self:    
        """
        Unique numeric identifier for the variable.
        """
            
        self._internal.id_val = id_val
    
        return self
    
    def name(self, name: str) -> typing.Self:    
        """
        Name of variable
        """
            
        self._internal.name = name
    
        return self
    
    def label(self, label: str) -> typing.Self:    
        """
        Optional display name
        """
            
        self._internal.label = label
    
        return self
    
    def description(self, description: str) -> typing.Self:    
        """
        Description of variable. It can be defined but `null`.
        """
            
        self._internal.description = description
    
        return self
    
    def value(self, query: typing.Union[str, dict[str, object]]) -> typing.Self:    
        """
        Query used to fetch values for a variable
        """
            
        self._internal.query = query
    
        return self
    
    def all_format(self, all_format: str) -> typing.Self:    
        """
        Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
        """
            
        self._internal.all_format = all_format
    
        return self
    

class DatasourceVariable(cogbuilder.Builder[dashboard.VariableModel]):    
    """
    A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
    """
    
    _internal: dashboard.VariableModel

    def __init__(self, name: str):
        self._internal = dashboard.VariableModel()        
        self._internal.name = name        
        self._internal.type_val = dashboard.VariableType.DATASOURCE

    def build(self) -> dashboard.VariableModel:
        return self._internal    
    
    def id_val(self, id_val: str) -> typing.Self:    
        """
        Unique numeric identifier for the variable.
        """
            
        self._internal.id_val = id_val
    
        return self
    
    def name(self, name: str) -> typing.Self:    
        """
        Name of variable
        """
            
        self._internal.name = name
    
        return self
    
    def label(self, label: str) -> typing.Self:    
        """
        Optional display name
        """
            
        self._internal.label = label
    
        return self
    
    def hide(self, hide: dashboard.VariableHide) -> typing.Self:    
        """
        Visibility configuration for the variable
        """
            
        self._internal.hide = hide
    
        return self
    
    def description(self, description: str) -> typing.Self:    
        """
        Description of variable. It can be defined but `null`.
        """
            
        self._internal.description = description
    
        return self
    
    def type_val(self, query: typing.Union[str, dict[str, object]]) -> typing.Self:    
        """
        Query used to fetch values for a variable
        """
            
        self._internal.query = query
    
        return self
    
    def all_format(self, all_format: str) -> typing.Self:    
        """
        Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
        """
            
        self._internal.all_format = all_format
    
        return self
    
    def current(self, current: dashboard.VariableOption) -> typing.Self:    
        """
        Shows current selected variable text/value on the dashboard
        """
            
        self._internal.current = current
    
        return self
    
    def multi(self, multi: bool) -> typing.Self:    
        """
        Whether multiple values can be selected or not from variable value list
        """
            
        self._internal.multi = multi
    
        return self
    
    def include_all(self, include_all: bool) -> typing.Self:    
        """
        Whether all value option is available or not
        """
            
        self._internal.include_all = include_all
    
        return self
    
    def all_value(self, all_value: str) -> typing.Self:    
        """
        Custom all value
        """
            
        self._internal.all_value = all_value
    
        return self
    
    def regex(self, regex: str) -> typing.Self:    
        """
        Optional field, if you want to extract part of a series name or metric node segment.
        Named capture groups can be used to separate the display text and value.
        """
            
        self._internal.regex = regex
    
        return self
    

class IntervalVariable(cogbuilder.Builder[dashboard.VariableModel]):    
    """
    A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
    """
    
    _internal: dashboard.VariableModel

    def __init__(self, name: str):
        self._internal = dashboard.VariableModel()        
        self._internal.name = name        
        self._internal.type_val = dashboard.VariableType.INTERVAL

    def build(self) -> dashboard.VariableModel:
        return self._internal    
    
    def id_val(self, id_val: str) -> typing.Self:    
        """
        Unique numeric identifier for the variable.
        """
            
        self._internal.id_val = id_val
    
        return self
    
    def name(self, name: str) -> typing.Self:    
        """
        Name of variable
        """
            
        self._internal.name = name
    
        return self
    
    def label(self, label: str) -> typing.Self:    
        """
        Optional display name
        """
            
        self._internal.label = label
    
        return self
    
    def hide(self, hide: dashboard.VariableHide) -> typing.Self:    
        """
        Visibility configuration for the variable
        """
            
        self._internal.hide = hide
    
        return self
    
    def description(self, description: str) -> typing.Self:    
        """
        Description of variable. It can be defined but `null`.
        """
            
        self._internal.description = description
    
        return self
    
    def values(self, query: typing.Union[str, dict[str, object]]) -> typing.Self:    
        """
        Query used to fetch values for a variable
        """
            
        self._internal.query = query
    
        return self
    
    def all_format(self, all_format: str) -> typing.Self:    
        """
        Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
        """
            
        self._internal.all_format = all_format
    
        return self
    
    def current(self, current: dashboard.VariableOption) -> typing.Self:    
        """
        Shows current selected variable text/value on the dashboard
        """
            
        self._internal.current = current
    
        return self
    
    def options(self, options: list[dashboard.VariableOption]) -> typing.Self:    
        """
        Options that can be selected for a variable.
        """
            
        self._internal.options = options
    
        return self
    

class TextBoxVariable(cogbuilder.Builder[dashboard.VariableModel]):    
    """
    A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
    """
    
    _internal: dashboard.VariableModel

    def __init__(self, name: str):
        self._internal = dashboard.VariableModel()        
        self._internal.name = name        
        self._internal.type_val = dashboard.VariableType.TEXTBOX

    def build(self) -> dashboard.VariableModel:
        return self._internal    
    
    def id_val(self, id_val: str) -> typing.Self:    
        """
        Unique numeric identifier for the variable.
        """
            
        self._internal.id_val = id_val
    
        return self
    
    def name(self, name: str) -> typing.Self:    
        """
        Name of variable
        """
            
        self._internal.name = name
    
        return self
    
    def label(self, label: str) -> typing.Self:    
        """
        Optional display name
        """
            
        self._internal.label = label
    
        return self
    
    def hide(self, hide: dashboard.VariableHide) -> typing.Self:    
        """
        Visibility configuration for the variable
        """
            
        self._internal.hide = hide
    
        return self
    
    def description(self, description: str) -> typing.Self:    
        """
        Description of variable. It can be defined but `null`.
        """
            
        self._internal.description = description
    
        return self
    
    def default_value(self, query: typing.Union[str, dict[str, object]]) -> typing.Self:    
        """
        Query used to fetch values for a variable
        """
            
        self._internal.query = query
    
        return self
    
    def all_format(self, all_format: str) -> typing.Self:    
        """
        Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
        """
            
        self._internal.all_format = all_format
    
        return self
    
    def current(self, current: dashboard.VariableOption) -> typing.Self:    
        """
        Shows current selected variable text/value on the dashboard
        """
            
        self._internal.current = current
    
        return self
    
    def options(self, options: list[dashboard.VariableOption]) -> typing.Self:    
        """
        Options that can be selected for a variable.
        """
            
        self._internal.options = options
    
        return self
    

class CustomVariable(cogbuilder.Builder[dashboard.VariableModel]):    
    """
    A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
    """
    
    _internal: dashboard.VariableModel

    def __init__(self, name: str):
        self._internal = dashboard.VariableModel()        
        self._internal.name = name        
        self._internal.type_val = dashboard.VariableType.CUSTOM

    def build(self) -> dashboard.VariableModel:
        return self._internal    
    
    def id_val(self, id_val: str) -> typing.Self:    
        """
        Unique numeric identifier for the variable.
        """
            
        self._internal.id_val = id_val
    
        return self
    
    def name(self, name: str) -> typing.Self:    
        """
        Name of variable
        """
            
        self._internal.name = name
    
        return self
    
    def label(self, label: str) -> typing.Self:    
        """
        Optional display name
        """
            
        self._internal.label = label
    
        return self
    
    def hide(self, hide: dashboard.VariableHide) -> typing.Self:    
        """
        Visibility configuration for the variable
        """
            
        self._internal.hide = hide
    
        return self
    
    def description(self, description: str) -> typing.Self:    
        """
        Description of variable. It can be defined but `null`.
        """
            
        self._internal.description = description
    
        return self
    
    def values(self, query: typing.Union[str, dict[str, object]]) -> typing.Self:    
        """
        Query used to fetch values for a variable
        """
            
        self._internal.query = query
    
        return self
    
    def all_format(self, all_format: str) -> typing.Self:    
        """
        Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
        """
            
        self._internal.all_format = all_format
    
        return self
    
    def current(self, current: dashboard.VariableOption) -> typing.Self:    
        """
        Shows current selected variable text/value on the dashboard
        """
            
        self._internal.current = current
    
        return self
    
    def multi(self, multi: bool) -> typing.Self:    
        """
        Whether multiple values can be selected or not from variable value list
        """
            
        self._internal.multi = multi
    
        return self
    
    def options(self, options: list[dashboard.VariableOption]) -> typing.Self:    
        """
        Options that can be selected for a variable.
        """
            
        self._internal.options = options
    
        return self
    
    def include_all(self, include_all: bool) -> typing.Self:    
        """
        Whether all value option is available or not
        """
            
        self._internal.include_all = include_all
    
        return self
    
    def all_value(self, all_value: str) -> typing.Self:    
        """
        Custom all value
        """
            
        self._internal.all_value = all_value
    
        return self
    